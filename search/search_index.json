{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"In-project CLI tooling support <p> Pronounced /\u02c8tu\u02d0l\u0259r/ (tool-er) </p> <p>ToolR is a tool similar to invoke and the next generation of python-tools-scripts.</p> <p>The goal is to quickly enable projects to write a Python module under the project's <code>tools/</code> sub-directory and it automatically becomes a sub command to the <code>toolr</code> CLI.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automatic-command-discovery","title":"Automatic Command Discovery","text":"<p>ToolR automatically discovers and registers commands from your project's <code>tools/</code> directory, making it easy to organize and maintain your project's CLI tools.</p>"},{"location":"#simple-command-definition","title":"Simple Command Definition","text":"<p>Define commands using simple Python functions with type hints. ToolR automatically generates argument parsing based on your function signatures.</p>"},{"location":"#nested-command-groups","title":"Nested Command Groups","text":"<p>Organize commands into logical groups and subgroups using dot notation, providing a clean and intuitive CLI structure.</p>"},{"location":"#rich-help-system","title":"Rich Help System","text":"<p>Built-in support for rich text formatting and automatic help generation from docstrings and type annotations.</p>"},{"location":"#third-party-command-support","title":"Third-Party Command Support","text":"<p>Extend ToolR's functionality by installing packages that provide additional commands through Python entry points.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install ToolR:</li> </ol> <pre><code>python -m pip install toolr\n</code></pre> <ol> <li>Create a tools package in your project root:</li> </ol> <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre> <ol> <li>Write your first command in <code>tools/example.py</code>:</li> </ol> <pre><code>from toolr import Context, command_group\n\ngroup = command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello to someone.\n\n    Args:\n      name: The name to say hello to.\n    \"\"\"\n    ctx.print(f\"Hello, {name}!\")\n</code></pre> <ol> <li>Run your command:</li> </ol> <pre><code>toolr example hello --name Alice\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#third-party-commands","title":"Third-Party Commands","text":"<p>ToolR supports 3rd-party commands from installable Python packages. Create packages that extend ToolR's functionality by defining commands and registering them as entry points.</p> <p>See the Advanced Topics section in the documentation for detailed information about creating 3rd-party command packages.</p>"},{"location":"examples/","title":"Examples","text":"<p>Here's some basic usage examples to start off of.</p>"},{"location":"examples/#simple-command","title":"Simple Command","text":"<p>The most basic command is a function with a context parameter:</p> tools/hello.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"greeting\", \"Greeting Commands\", \"Commands for greeting users\")\n\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello.\n\n    Args:\n        name: The name of the person to greet.\n    \"\"\"\n    ctx.info(\"Hello\", name, \"!\")\n</code></pre> <p>Run with:</p> <pre><code>toolr greeting hello --name Alice\n# Output: Hello, Alice!\n</code></pre>"},{"location":"examples/#command-with-multiple-arguments","title":"Command with Multiple Arguments","text":"tools/calculator.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"math\", \"Math Commands\", \"Basic mathematical operations\")\n\n\n@group.command\ndef add(ctx: Context, a: int, b: int):\n    \"\"\"Add two numbers together.\n\n    Args:\n        a: First number.\n        b: Second number.\n    \"\"\"\n    result = a + b\n    ctx.info(f\"{a} + {b} = {result}\")\n    return result\n</code></pre> <p>Run with:</p> <pre><code>toolr math add 5 3\n# Output: 5 + 3 = 8\n</code></pre>"},{"location":"examples/#boolean-flags","title":"Boolean Flags","text":"tools/example.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n\n@group.command\ndef process(ctx: Context, verbose: bool = False, dry_run: bool = False):\n    \"\"\"Process something with optional flags.\n\n    Args:\n        verbose: Whether to print verbose output.\n        dry_run: Whether to perform a dry run (no changes will be made).\n    \"\"\"\n    if verbose:\n        ctx.info(\"Verbose mode enabled\")\n\n    if dry_run:\n        ctx.info(\"Dry run mode - no changes will be made\")\n        return\n\n    ctx.info(\"Processing...\")\n</code></pre> <p>Run with:</p> <pre><code>toolr example process --verbose --dry-run\n# Output: Verbose mode enabled\n#         Dry run mode - no changes will be made\n</code></pre>"},{"location":"examples/#list-arguments","title":"List Arguments","text":"tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, files: list[str]):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre> <p>Run with:</p> <pre><code>toolr files process-files file1.txt file2.txt file3.txt\n# Output: Processing file1.txt...\n#         Processing file2.txt...\n#         Processing file3.txt...\n</code></pre> <p>The above command could also be defined like:</p> tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, *files: str):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre>"},{"location":"examples/#using-the-context","title":"Using the Context","text":"<p>The <code>ctx</code> parameter provides access to useful utilities:</p> tools/system.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"system\", \"System Commands\", \"System operations\")\n\n\n@group.command\ndef info(ctx: Context) -&gt; None:\n    \"\"\"Show system information.\n\n    Displays repository root, Python version, and other system details.\n    \"\"\"\n    # Access the repository root\n    ctx.info(f\"Repository root: {ctx.repo_root}\")\n\n    # Run a command\n    result = ctx.run(\"python\", \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", result.stdout.read().strip())\n\n    # Rich console output formatting available\n    ctx.print(\"[bold green]System info retrieved successfully![/bold green]\")\n\n\n@group.command\ndef check_disk(ctx: Context, path: str = \".\") -&gt; None:\n    \"\"\"Check disk usage for a path.\n\n    Args:\n        path: The path to check disk usage for. Defaults to current directory.\n    \"\"\"\n    # Run command with error handling\n    try:\n        result = ctx.run(\"du\", \"-sh\", path, capture_output=True, stream_output=False)\n        if result.returncode == 0:\n            ctx.print(f\"[green]Disk usage for {path}: {result.stdout.read().strip()}[/green]\")\n        else:\n            ctx.error(f\"Failed to check disk usage: {result.stderr.read().strip()}\")\n    except Exception as e:\n        ctx.error(f\"Error checking disk usage: {e}\")\n\n\n@group.command\ndef network_test(ctx: Context, host: str = \"8.8.8.8\", count: int = 3) -&gt; None:\n    \"\"\"Test network connectivity to a host.\n\n    Args:\n        host: The host to test connectivity to. Defaults to Google's DNS (8.8.8.8).\n        count: Number of ping packets to send. Defaults to 3.\n    \"\"\"\n    ctx.info(f\"Testing connectivity to {host}\")\n\n    result = ctx.run(\"ping\", \"-c\", count, host, capture_output=True, stream_output=False)\n\n    if result.returncode == 0:\n        ctx.print(f\"[green]Network connectivity to {host} is working[/green]\")\n        # Extract ping statistics\n        lines = result.stdout.read().decode().split(\"\\n\")\n        for line in lines:\n            if \"packets transmitted\" in line:\n                ctx.info(f\"Ping statistics: {line.strip()}\")\n    else:\n        ctx.error(f\"Network connectivity to {host} failed\")\n</code></pre> <p>Run with:</p> <pre><code>toolr system info\n</code></pre>"},{"location":"examples/#function-name-conversion","title":"Function Name Conversion","text":"<p>ToolR automatically converts Python function names with underscores to command names with hyphens:</p> tools/function_names.py<pre><code>\"\"\"Example demonstrating function name to command name conversion.\n\nThis example shows how function names with underscores are automatically converted\nto command names with hyphens when using the @command decorator without specifying\na name.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\n# Create a command group\ntools = command_group(\n    \"names\",\n    \"Examples for function name to command name conversion\",\n    \"Various examples for function name to command name conversion\",\n)\n\n\n# Define commands using function names - they will be automatically converted\n@tools.command\ndef simple_function(ctx: Context) -&gt; None:  # -&gt; simple-function\n    \"\"\"A simple function.\"\"\"\n\n\n@tools.command\ndef function_with_underscores(ctx: Context) -&gt; None:  # -&gt; function-with-underscores\n    \"\"\"A function with underscores in the name.\"\"\"\n\n\n@tools.command\ndef multiple_underscores_in_name(ctx: Context) -&gt; None:  # -&gt; multiple-underscores-in-name\n    \"\"\"A function with multiple underscores.\"\"\"\n\n\n@tools.command\ndef _leading_underscore(ctx: Context) -&gt; None:  # -&gt; -leading-underscore\n    \"\"\"A function with a leading underscore.\"\"\"\n\n\n@tools.command\ndef trailing_underscore_(ctx: Context) -&gt; None:  # -&gt; trailing-underscore-\n    \"\"\"A function with a trailing underscore.\"\"\"\n\n\n@tools.command\ndef _both_underscores_(ctx: Context) -&gt; None:  # -&gt; -both-underscores-\n    \"\"\"A function with both leading and trailing underscores.\"\"\"\n</code></pre> <p>This example demonstrates how function names like <code>function_with_underscores</code> become command names like <code>function-with-underscores</code> in the CLI.</p> <pre><code>toolr names -h\nUsage: toolr names [-h] {simple-function,function-with-underscores,multiple-underscores-in-name,-leading-underscore,trailing-underscore-,-both-underscores-} ...\n\nVarious examples for function name to command name conversion\n\nOptions:\n  -h, --help            show this help message and exit\n\nExamples For Function Name To Command Name Conversion:\n  Various examples for function name to command name conversion\n\n  {simple-function,function-with-underscores,multiple-underscores-in-name,-leading-underscore,trailing-underscore-,-both-underscores-}\n    simple-function     A simple function.\n    function-with-underscores\n                        A function with underscores in the name.\n    multiple-underscores-in-name\n                        A function with multiple underscores.\n    -leading-underscore\n                        A function with a leading underscore.\n    trailing-underscore-\n                        A function with a trailing underscore.\n    -both-underscores-  A function with both leading and trailing underscores.\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> </ul>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>python -m pip install toolr\n</code></pre>"},{"location":"installation/#project-setup","title":"Project Setup","text":"<p>After installation, create a <code>tools/</code> package in your project root:</p> <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre> <p>This directory will contain all your CLI commands. ToolR will automatically discover and register any Python modules in this directory.</p>"},{"location":"installation/#verification","title":"Verification","text":"<p>To verify the installation, run:</p> <pre><code>toolr --help\n</code></pre> <p>You should see the ToolR help output with available commands.</p> <pre><code>Usage: toolr [-h] [--version] [--timestamps | --no-timestamps] [--quiet | --debug] [--timeout SECONDS] [--no-output-timeout-secs SECONDS] {} ...\n\nIn-project CLI tooling support\n\nOptions:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n\nLogging:\n  --timestamps, --ts    Add time stamps to logs (default: False)\n  --no-timestamps, --nts\n                        Remove time stamps from logs (default: True)\n  --quiet, -q           Disable logging (default: False)\n  --debug, -d           Show debug messages (default: False)\n\nRun Subprocess Options:\n  These options apply to ctx.run() calls\n\n  --timeout, --timeout-secs SECONDS\n                        Timeout in seconds for the command to finish. (default: None)\n  --no-output-timeout-secs, --nots SECONDS\n                        Timeout if no output has been seen for the provided seconds. (default: None)\n\nCommands:\n  These commands are discovered under `&lt;repo-root&gt;/tools` recursively.\n\n  {}\n\nMore information about ToolR can be found at https://github.com/s0undt3ch/toolr\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development or to use the latest version:</p> <pre><code># Clone the repository\ngit clone https://github.com/s0undt3ch/toolr.git\ncd toolr\n\n# Install in development mode\nuv sync --dev\n</code></pre>"},{"location":"installation/#third-party-command-packages","title":"Third-Party Command Packages","text":"<p>ToolR supports 3rd-party command packages that extend its functionality. These packages are automatically discovered when installed alongside ToolR.</p> <p>To install a 3rd-party command package:</p> <pre><code>python -m pip install &lt;package-name&gt;\n</code></pre> <p>The package's commands will be automatically available in the ToolR CLI. See the Advanced Topics section for information about creating your own 3rd-party command packages.</p>"},{"location":"reference/toolr/_context/","title":"toolr._context","text":"<p>This module provides the Context class, which is passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.ConsoleVerbosity","title":"ConsoleVerbosity","text":"<p>               Bases: <code>IntEnum</code></p> <p>Console verbosity levels.</p>"},{"location":"reference/toolr/_context/#toolr._context.ConsoleVerbosity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the console verbosity.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the console verbosity.\n    \"\"\"\n    return self.name.lower()\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context","title":"Context","text":"<p>               Bases: <code>Struct</code></p> <p>Context object passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.Context.prompt","title":"prompt","text":"<pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[bool],\n    *,\n    default: bool | None = None,\n    show_default: bool = True,\n) -&gt; bool\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[str],\n    *,\n    password: bool = True,\n    default: str | None = None,\n    case_sensitive: bool = True,\n) -&gt; str\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[int],\n    *,\n    choices: list[str] | None = None,\n    default: int | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; int\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[float],\n    *,\n    choices: list[str] | None = None,\n    default: float | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; float\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: None = None,\n    *,\n    choices: list[str] | None = None,\n    default: None = None,\n    case_sensitive: bool = True,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str\n</code></pre> <pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[str | int | float | bool]\n    | None = None,\n    *,\n    password: bool = False,\n    case_sensitive: bool = True,\n    choices: list[str] | None = None,\n    default: str | int | float | bool | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str | int | float | bool\n</code></pre> <p>Prompt the user for input.</p> <p>This is a wrapper around rich.prompt.Prompt.ask.</p> <p>See rich.prompt.Prompt.ask for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def prompt(\n    self,\n    prompt: TextType,\n    expected_type: type[str | int | float | bool] | None = None,\n    *,\n    password: bool = False,\n    case_sensitive: bool = True,\n    choices: list[str] | None = None,\n    default: str | int | float | bool | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str | int | float | bool:\n    \"\"\"\n    Prompt the user for input.\n\n    This is a wrapper around [rich.prompt.Prompt.ask][rich.prompt].\n\n    See [rich.prompt.Prompt.ask][rich.prompt] for more details.\n    \"\"\"\n    return self._prompt(\n        prompt,\n        expected_type,\n        password=password,\n        case_sensitive=case_sensitive,\n        choices=choices,\n        default=default,\n        show_default=show_default,\n        show_choices=show_choices,\n    )\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.print","title":"print","text":"<pre><code>print(\n    *args: ConsoleRenderable | RichCast | str, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Print to stdout.</p> <p>This is a wrapper around :func:<code>rich.console.Console.print</code>.</p> <p>See :func:<code>rich.console.Console.print</code> for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def print(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print to stdout.\n\n    This is a wrapper around :func:`rich.console.Console.print`.\n\n    See :func:`rich.console.Console.print` for more details.\n    \"\"\"\n    self._console_stdout.print(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.debug","title":"debug","text":"<pre><code>debug(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print debug message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def debug(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print debug message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.VERBOSE:\n        kwargs.update(style=\"log-debug\", _stack_offset=2)\n        self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.info","title":"info","text":"<pre><code>info(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print info message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def info(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print info message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.NORMAL:\n        kwargs.update(style=\"log-info\", _stack_offset=2)\n        self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.warn","title":"warn","text":"<pre><code>warn(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print warning message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def warn(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print warning message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-warning\", _stack_offset=2)\n    self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.error","title":"error","text":"<pre><code>error(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print error message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def error(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print error message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-error\", _stack_offset=2)\n    self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.exit","title":"exit","text":"<pre><code>exit(\n    status: int = 0, message: str | None = None\n) -&gt; NoReturn\n</code></pre> <p>Exit the command execution.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def exit(self, status: int = 0, message: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Exit the command execution.\n    \"\"\"\n    if message is not None:\n        if status == 0:\n            style = \"exit-ok\"\n        else:\n            style = \"exit-failure\"\n        self._console_stderr.print(message, style=style)\n    self.parser.exit(status)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.run","title":"run","text":"<pre><code>run(\n    *cmdline: str,\n    stream_output: bool = True,\n    capture_output: bool = False,\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n    **kwargs: Any,\n) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command with the given arguments.</p> <p>This is a wrapper around toolr.utils.command.run that provides a simpler interface for command functions.</p> <p>Parameters:</p> Name Type Description Default <code>cmdline</code> <code>str</code> <p>Command line to run</p> <code>()</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>True</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to toolr.utils.command.run</p> <code>{}</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult instance.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def run(\n    self,\n    *cmdline: str,\n    stream_output: bool = True,\n    capture_output: bool = False,\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n    **kwargs: Any,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"Run a command with the given arguments.\n\n    This is a wrapper around [toolr.utils.command.run][] that provides\n    a simpler interface for command functions.\n\n    Args:\n        cmdline: Command line to run\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n        kwargs: Additional keyword arguments to pass to [toolr.utils.command.run][]\n\n    Returns:\n        CommandResult instance.\n    \"\"\"\n    self.debug(f\"\"\"Running '{\" \".join(cmdline)}'\"\"\")\n    return command.run(\n        cmdline,\n        stream_output=stream_output,\n        capture_output=capture_output,\n        timeout_secs=timeout_secs,\n        no_output_timeout_secs=no_output_timeout_secs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.chdir","title":"chdir","text":"<pre><code>chdir(path: str | Path) -&gt; Iterator[Path]\n</code></pre> <p>Change the working directory for this context.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The new working directory path</p> required <p>Returns:</p> Type Description <code>Iterator[Path]</code> <p>Iterator yielding the new working directory as a Path object</p> <p>This is a context manager, so it should be used with 'with':</p> <p>.. code-block:: python</p> <pre><code>with ctx.chdir(\"/some/path\") as p:\n    # Do something in /some/path\n    # p is the Path object for /some/path\n</code></pre> Source code in <code>python/toolr/_context.py</code> <pre><code>@contextmanager\ndef chdir(self, path: str | pathlib.Path) -&gt; Iterator[pathlib.Path]:\n    \"\"\"Change the working directory for this context.\n\n    Args:\n        path: The new working directory path\n\n    Returns:\n        Iterator yielding the new working directory as a Path object\n\n    This is a context manager, so it should be used with 'with':\n\n    .. code-block:: python\n\n        with ctx.chdir(\"/some/path\") as p:\n            # Do something in /some/path\n            # p is the Path object for /some/path\n    \"\"\"\n    cwd = pathlib.Path.cwd()\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    try:\n        os.chdir(path)\n        yield path\n    finally:\n        if not cwd.exists():\n            self.error(f\"Unable to change back to path {cwd}\")\n        else:\n            os.chdir(cwd)\n</code></pre>"},{"location":"reference/toolr/_exc/","title":"toolr._exc","text":""},{"location":"reference/toolr/_exc/#toolr._exc.ToolrError","title":"ToolrError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Toolr errors.</p>"},{"location":"reference/toolr/_exc/#toolr._exc.SignatureError","title":"SignatureError","text":"<p>               Bases: <code>ToolrError</code></p> <p>Exception raised when a function signature is invalid.</p>"},{"location":"reference/toolr/_parser/","title":"toolr._parser","text":""},{"location":"reference/toolr/_parser/#toolr._parser.Parser","title":"Parser","text":"<p>               Bases: <code>Struct</code></p> <p>Singleton parser class that wraps argparse.</p>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.parse_args","title":"parse_args","text":"<pre><code>parse_args(argv: list[str] | None = None) -&gt; Namespace\n</code></pre> <p>Parse CLI.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def parse_args(self, argv: list[str] | None = None) -&gt; Namespace:\n    \"\"\"\n    Parse CLI.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert self.context is not None\n        assert self.parser is not None\n\n    # Log the argv getting executed\n    self.context.debug(f\"Tools executing 'sys.argv': {sys.argv}\")\n    # Process registered imports to allow other modules to register commands\n    # self._process_registered_tool_modules()\n    options = self.parser.parse_args(argv)\n    verbosity = ConsoleVerbosity.NORMAL\n    if options.quiet:\n        verbosity = ConsoleVerbosity.QUIET\n        logging.root.setLevel(logging.CRITICAL + 1)\n    elif options.debug:\n        verbosity = ConsoleVerbosity.VERBOSE\n        logging.root.setLevel(logging.DEBUG)\n    else:\n        logging.root.setLevel(logging.INFO)\n    if options.timestamps:\n        for handler in logging.root.handlers:\n            handler.setFormatter(_logs.TIMESTAMP_FORMATTER)\n    else:\n        for handler in logging.root.handlers:\n            handler.setFormatter(_logs.NO_TIMESTAMP_FORMATTER)\n\n    # Late import to avoid circular import issues\n    from toolr.utils._console import Consoles  # noqa: PLC0415\n\n    # Reset verbosity and consoles after parsing the CLI\n    consoles = Consoles.setup(verbosity)\n    structs.force_setattr(self.context, \"verbosity\", verbosity)\n    structs.force_setattr(self.context, \"_console_stderr\", consoles.stderr)\n    structs.force_setattr(self.context, \"_console_stdout\", consoles.stdout)\n    if \"func\" not in options:\n        self.context.exit(1, \"No command was passed.\")\n    structs.force_setattr(self, \"options\", options)\n    log.debug(\"CLI parsed options %s\", options)\n    return options\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the command.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the command.\n    \"\"\"\n    if self.options is None:\n        err_msg = \"parser.parse_args() was not called.\"\n        raise RuntimeError(err_msg)\n    self.options.func(self.context, self.options)\n    self.exit(0)\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(attr: str) -&gt; Any\n</code></pre> <p>Proxy unknown attributes to the parser instance.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Any:\n    \"\"\"\n    Proxy unknown attributes to the parser instance.\n    \"\"\"\n    if attr == \"options\":\n        return self.__getattribute__(attr)\n    return getattr(self.parser, attr)\n</code></pre>"},{"location":"reference/toolr/_registry/","title":"toolr._registry","text":""},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup","title":"CommandGroup","text":"<p>               Bases: <code>Struct</code></p> <p>A group of commands under a common namespace.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Get the full dot-notation name of this command group.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command","title":"command","text":"<pre><code>command(name: F) -&gt; F\n</code></pre><pre><code>command(name: str) -&gt; Callable[[F], F]\n</code></pre> <pre><code>command(name: str | F) -&gt; Callable[[F], F] | F\n</code></pre> <p>Register a new command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | F</code> <p>Name of the command. If not passed, the function name will be used.</p> required <p>Returns:</p> Type Description <code>Callable[[F], F] | F</code> <p>A decorator function that registers the command</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command(self, name: str | F) -&gt; Callable[[F], F] | F:\n    \"\"\"Register a new command.\n\n    Args:\n        name: Name of the command. If not passed, the function name will be used.\n\n    Returns:\n        A decorator function that registers the command\n    \"\"\"\n    if isinstance(name, FunctionType):\n        # If we were not passed a name in the decorator call, we're being called with a function\n        # and we need to use the function name as the command name\n        return self.command(name.__name__.replace(\"_\", \"-\"))(name)\n\n    if TYPE_CHECKING:\n        assert isinstance(name, str)\n\n    def decorator(func: F) -&gt; F:\n        if name in self.__commands:\n            log.debug(\"Command '%s' already exists in group '%s', overriding\", name, self.full_name)\n        self.__commands[name] = func\n        return func\n\n    return decorator\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command_group","title":"command_group","text":"<pre><code>command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n) -&gt; CommandGroup\n</code></pre> <p>Create a nested command group within this group.</p> <p>This is a wrapper around the command_group function that sets the parent to this group's full name.</p> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    self,\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Create a nested command group within this group.\n\n    This is a wrapper around the [command_group][toolr._registry.command_group] function\n    that sets the parent to this group's full name.\n\n    Returns:\n        A CommandGroup instance\n    \"\"\"\n    return command_group(\n        name,\n        title,\n        description=description,\n        parent=self.full_name,\n        long_description=long_description,\n        docstring=docstring,\n    )\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.get_commands","title":"get_commands","text":"<pre><code>get_commands() -&gt; dict[str, Callable[..., Any]]\n</code></pre> <p>Get the commands in this group.</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def get_commands(self) -&gt; dict[str, Callable[..., Any]]:\n    \"\"\"Get the commands in this group.\"\"\"\n    return {name: self.__commands[name] for name in sorted(self.__commands)}\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry","title":"CommandRegistry","text":"<p>               Bases: <code>Struct</code></p> <p>Registry for CLI commands and their subcommands.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.parser","title":"parser  <code>property</code>","text":"<pre><code>parser: Parser\n</code></pre> <p>Get the parser for this registry.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.discover_and_build","title":"discover_and_build","text":"<pre><code>discover_and_build(parser: Parser | None = None) -&gt; None\n</code></pre> <p>Discover all commands and build the parser hierarchy.</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def discover_and_build(self, parser: Parser | None = None) -&gt; None:\n    \"\"\"Discover all commands and build the parser hierarchy.\"\"\"\n    if parser is not None:\n        self._set_parser(parser)\n    self._discover_commands()\n    self._build_parsers()\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.command_group","title":"command_group","text":"<pre><code>command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n    parent: str | None = None,\n) -&gt; CommandGroup\n</code></pre> <p>Register a new command group.</p> <p>If you pass <code>docstring</code>, you won't be allowed to pass <code>description</code> or <code>long_description</code>. Those will be parsed by docstring-parser. The first line of the docstring will be used as the description, the rest will be used as the long description.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the command group</p> required <code>title</code> <code>str</code> <p>Title for the command group</p> required <code>description</code> <code>str | None</code> <p>Description for the command group</p> <code>None</code> <code>long_description</code> <code>str | None</code> <p>Long description for the command group</p> <code>None</code> <code>docstring</code> <code>str | None</code> <p>Docstring for the command group</p> <code>None</code> <code>parent</code> <code>str | None</code> <p>Optional parent command path using dot notation (e.g. \"tools.docker.build\")</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n    parent: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Register a new command group.\n\n    If you pass ``docstring``, you won't be allowed to pass ``description`` or ``long_description``.\n    Those will be parsed by [docstring-parser](https://pypi.org/project/docstring-parser/).\n    The first line of the docstring will be used as the description, the rest will be used as the long description.\n\n    Args:\n        name: Name of the command group\n        title: Title for the command group\n        description: Description for the command group\n        long_description: Long description for the command group\n        docstring: Docstring for the command group\n        parent: Optional parent command path using dot notation (e.g. \"tools.docker.build\")\n\n    Returns:\n        A CommandGroup instance\n\n    \"\"\"\n    if parent is None:\n        parent = \"tools\"\n\n    collector = _get_command_group_storage()\n\n    group: CommandGroup | None = collector.get(f\"{parent}.{name}\")\n    if group is not None:\n        # In this case, we return the existing group\n        log.debug(\"Command group '%s' already exists, returning existing group\", f\"{parent}.{name}\")\n        return group\n\n    if docstring is not None:\n        if description is not None or long_description is not None:\n            err_msg = \"You can't pass both docstring and description or long_description\"\n            raise ValueError(err_msg)\n        parsed_docstring = parse_docstring(docstring)\n        description = parsed_docstring.short_description\n        long_description = parsed_docstring.long_description\n    elif description is None:\n        err_msg = \"You must at least pass either the 'docstring' or 'description' argument\"\n        raise ValueError(err_msg)\n\n    if TYPE_CHECKING:\n        assert description is not None\n\n    # Create the command group\n    collector[f\"{parent}.{name}\"] = group = CommandGroup(\n        name=name,\n        title=title,\n        description=description,\n        parent=parent,\n        long_description=long_description,\n    )\n    return group\n</code></pre>"},{"location":"reference/toolr/testing/","title":"toolr.testing","text":"<p>Utilities for testing ToolR and supported commands.</p>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester","title":"CommandsTester","text":"<p>Helper class to simplify testing command discovery.</p>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.collected_command_groups","title":"collected_command_groups","text":"<pre><code>collected_command_groups() -&gt; dict[str, CommandGroup]\n</code></pre> <p>Get the collected command groups.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def collected_command_groups(self) -&gt; dict[str, CommandGroup]:\n    \"\"\"\n    Get the collected command groups.\n    \"\"\"\n    return {**self.command_group_collector}\n</code></pre>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the context manager.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"\n    Enter the context manager.\n    \"\"\"\n    sys.modules.clear()\n    sys.modules.update(self.sys_modules)\n    os.chdir(self.search_path)\n    if self.skip_loading_entry_points:\n        self.entry_points_patcher.start()\n    self.command_group_patcher.start()\n    sys.path.insert(0, str(self.search_path))\n    return self\n</code></pre>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: object) -&gt; None\n</code></pre> <p>Exit the context manager.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def __exit__(self, *args: object) -&gt; None:\n    \"\"\"\n    Exit the context manager.\n    \"\"\"\n    os.chdir(self.cwd)\n    self.command_group_patcher.stop()\n    if self.skip_loading_entry_points:\n        self.entry_points_patcher.stop()\n    self.command_group_collector.clear()\n    sys.path[:] = self.sys_path\n</code></pre>"},{"location":"reference/toolr/utils/_console/","title":"toolr.utils._console","text":""},{"location":"reference/toolr/utils/_docstrings/","title":"toolr.utils._docstrings","text":""},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.parse_docstring","title":"parse_docstring","text":"<pre><code>parse_docstring(docstring: str) -&gt; Docstring\n</code></pre> <p>Parse a docstring into a Docstring object.</p> Source code in <code>python/toolr/utils/_docstrings.py</code> <pre><code>def parse_docstring(docstring: str) -&gt; Docstring:\n    \"\"\"Parse a docstring into a Docstring object.\"\"\"\n    parser = GoogleParser()\n    parse_docstring = parser.parse(docstring)\n    short_description = parse_docstring.short_description\n    long_description = parse_docstring.long_description or short_description\n\n    if TYPE_CHECKING:\n        assert short_description is not None\n        assert long_description is not None\n\n    params = {param.arg_name: param.description for param in parse_docstring.params}\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        params=params,\n    )\n</code></pre>"},{"location":"reference/toolr/utils/_logs/","title":"toolr.utils._logs","text":""},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.DuplicateTimesFormatter","title":"DuplicateTimesFormatter","text":"<pre><code>DuplicateTimesFormatter(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Formatter that adds a timestamp to the message, if it's not a duplicate.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    super().__init__(*args, **kwargs)\n    self._last_timestamp: str | None = None\n</code></pre>"},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.include_timestamps","title":"include_timestamps","text":"<pre><code>include_timestamps() -&gt; bool\n</code></pre> <p>Return True if any of the configured logging handlers includes timestamps.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def include_timestamps() -&gt; bool:\n    \"\"\"\n    Return True if any of the configured logging handlers includes timestamps.\n    \"\"\"\n    return any(handler.formatter is TIMESTAMP_FORMATTER for handler in logging.root.handlers)\n</code></pre>"},{"location":"reference/toolr/utils/_signature/","title":"toolr.utils._signature","text":"<p>Utilities to parse function signatures.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.VarArg","title":"VarArg","text":"<p>               Bases: <code>Arg</code>, <code>Struct</code></p> <p>VarArg is a special case of Arg that is used to represent a variable number of arguments.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.arg","title":"arg","text":"<pre><code>arg(\n    *,\n    aliases: list[str] | None = None,\n    required: bool | None = None,\n    metavar: str | None = None,\n    action: str | None = None,\n    choices: list[Any] | None = None,\n    nargs: NargsType | None = None,\n) -&gt; ArgumentAnnotation\n</code></pre> <p>Create an ArgumentAnnotation.</p> <p>This function is meant to be used with :class:<code>typing.Annotated</code> to create an ArgumentAnnotation.</p> <p>Parameters:</p> Name Type Description Default <code>aliases</code> <code>list[str] | None</code> <p>Aliases for the argument.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Whether the argument is required.</p> <code>None</code> <code>metavar</code> <code>str | None</code> <p>The metavar for the argument.</p> <code>None</code> <code>action</code> <code>str | None</code> <p>The action for the argument.</p> <code>None</code> <code>choices</code> <code>list[Any] | None</code> <p>The choices for the argument.</p> <code>None</code> <code>nargs</code> <code>NargsType | None</code> <p>The number of arguments to accept.</p> <code>None</code> Source code in <code>python/toolr/utils/_signature.py</code> <pre><code>def arg(\n    *,\n    aliases: list[str] | None = None,\n    required: bool | None = None,\n    metavar: str | None = None,\n    action: str | None = None,\n    choices: list[Any] | None = None,\n    nargs: NargsType | None = None,\n) -&gt; ArgumentAnnotation:\n    \"\"\"\n    Create an ArgumentAnnotation.\n\n    This function is meant to be used with :class:`typing.Annotated` to create an ArgumentAnnotation.\n\n    Args:\n        aliases: Aliases for the argument.\n        required: Whether the argument is required.\n        metavar: The metavar for the argument.\n        action: The action for the argument.\n        choices: The choices for the argument.\n        nargs: The number of arguments to accept.\n    \"\"\"\n    return ArgumentAnnotation(\n        aliases=aliases, required=required, metavar=metavar, action=action, choices=choices, nargs=nargs\n    )\n</code></pre>"},{"location":"reference/toolr/utils/command/","title":"toolr.utils.command","text":"<p>Public interface to the rust command extension module.</p> <p>It provides a simple interface to run commands and stream/capture their output.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.CommandResult","title":"CommandResult","text":"<p>               Bases: <code>Struct</code>, <code>Generic[T]</code></p> <p>The result of a command execution.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.run","title":"run","text":"<pre><code>run(\n    args: Sequence[str],\n    *,\n    cwd: str | Path | None = None,\n    env: ENVIRON = None,\n    input: str | bytes | None = None,\n    stream_output: bool = False,\n    capture_output: bool = False,\n    text: bool = True,\n    encoding: str | None = \"utf-8\",\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command in a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str]</code> <p>Command and arguments to run</p> required <code>cwd</code> <code>str | Path | None</code> <p>Current working directory to run the command in. Defaults to the current directory.</p> <code>None</code> <code>env</code> <code>ENVIRON</code> <p>Environment variables to pass to the command</p> <code>None</code> <code>input</code> <code>str | bytes | None</code> <p>Input data to pass to the command</p> <code>None</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>False</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>text</code> <code>bool</code> <p>Whether to return output as text or bytes</p> <code>True</code> <code>encoding</code> <code>str | None</code> <p>Encoding to use for text output</p> <code>'utf-8'</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult object containing stdout, stderr, and return code</p> <p>Raises:</p> Type Description <code>CommandError</code> <p>If any of the pre-run checks fail or an operational failure happens.</p> <code>CommandTimeoutError</code> <p>If the command times out</p> <code>CommandTimeoutNoOutputError</code> <p>If the command produces no output for too long</p> Source code in <code>python/toolr/utils/command.py</code> <pre><code>def run(  # noqa: PLR0915\n    args: Sequence[str],\n    *,\n    cwd: str | pathlib.Path | None = None,\n    env: ENVIRON = None,\n    input: str | bytes | None = None,  # noqa: A002\n    stream_output: bool = False,\n    capture_output: bool = False,\n    text: bool = True,\n    encoding: str | None = \"utf-8\",\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"\n    Run a command in a subprocess.\n\n    Args:\n        args: Command and arguments to run\n        cwd: Current working directory to run the command in. Defaults to the current directory.\n        env: Environment variables to pass to the command\n        input: Input data to pass to the command\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        text: Whether to return output as text or bytes\n        encoding: Encoding to use for text output\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n\n    Returns:\n        CommandResult object containing stdout, stderr, and return code\n\n    Raises:\n        CommandError: If any of the pre-run checks fail or an operational failure happens.\n        CommandTimeoutError: If the command times out\n        CommandTimeoutNoOutputError: If the command produces no output for too long\n    \"\"\"\n    # Stream output is only supported with text=True\n    if stream_output and not text:\n        err_msg = \"stream_output=True requires text=True\"\n        raise ValueError(err_msg)\n\n    if cwd is None:\n        cwd = pathlib.Path.cwd()\n\n    # Initialize file variables with explicit types\n    stdout_file: IO[Any] | None = None\n    stderr_file: IO[Any] | None = None\n    stdout_fd: int | None = None\n    stderr_fd: int | None = None\n    sys_stdout_fd: int | None = None\n    sys_stderr_fd: int | None = None\n\n    try:\n        # Process the input data\n        input_bytes = None\n        if input is not None:\n            if isinstance(input, str):\n                input_bytes = input.encode(encoding or \"utf-8\")\n            else:\n                input_bytes = input\n\n        # Prepare environment\n        env_dict: dict[str, str] = {}\n        if env:\n            env_dict.update(env)\n        else:\n            # If no environment provided, inherit the current environment\n            env_dict.update(os.environ)\n\n        # Set up stdout/stderr handling\n        if capture_output:\n            if text:\n                stdout_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n            else:\n                stdout_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n\n            stdout_fd = stdout_file.fileno()\n            stderr_fd = stderr_file.fileno()\n\n        # Get sys.stdout and sys.stderr file descriptors if streaming\n        if stream_output:\n            try:\n                sys_stdout_fd = sys.stdout.fileno()\n                sys_stderr_fd = sys.stderr.fileno()\n            except io.UnsupportedOperation:\n                if TYPE_CHECKING:\n                    assert sys.__stdout__ is not None\n                    assert sys.__stderr__ is not None\n\n                sys_stdout_fd = sys.__stdout__.fileno()\n                sys_stderr_fd = sys.__stderr__.fileno()\n\n        # Run the command implementation\n        command_args = list(args)\n        returncode = run_command_impl(\n            command_args,\n            cwd=str(cwd),\n            env=env_dict,\n            input=input_bytes,\n            stdout_fd=stdout_fd,\n            stderr_fd=stderr_fd,\n            sys_stdout_fd=sys_stdout_fd,\n            sys_stderr_fd=sys_stderr_fd,\n            timeout_secs=timeout_secs,\n            no_output_timeout_secs=no_output_timeout_secs,\n        )\n\n        if TYPE_CHECKING:\n            assert stdout_file is not None\n            assert stderr_file is not None\n\n        # Rewind files for reading\n        if stdout_file:\n            stdout_file.seek(0)\n        if stderr_file:\n            stderr_file.seek(0)\n\n        # Return the result with correct typing\n        if text is True:\n            return cast(\n                \"CommandResult[str]\",\n                CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n            )\n        return cast(\n            \"CommandResult[bytes]\",\n            CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n        )\n\n    except Exception as exc:\n        # Clean up on error\n        if stdout_file and hasattr(stdout_file, \"close\"):\n            stdout_file.close()\n        if stderr_file and hasattr(stderr_file, \"close\"):\n            stderr_file.close()\n\n        # Re-raise the exception\n        raise exc from None\n</code></pre>"},{"location":"usage/","title":"How to use","text":"<p>It's important to note that ToolR relies on proper typing of the python functions that will become commands. If fact, it will complain and error out if typing information is missing or unable to parse.</p> <p>It's also important to note that the function must also have a properly written docstring using google style docstrings.</p> <pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", title=\"Example\", description=\"Example commands\")\n\n\n@group.command\ndef echo(ctx: Context, what: str):\n    \"\"\"\n    Command title line.\n\n    This is the command description, it can span several lines.\n\n    Args:\n        what: What to echo.\n    \"\"\"\n    ctx.print(what)\n</code></pre> <p>Let's see it!</p> <pre><code>toolr example -h\nUsage: toolr example [-h] {echo} ...\n\nExample commands\n\nOptions:\n  -h, --help  show this help message and exit\n\nExample:\n  Example commands\n\n  {echo}\n    echo      Command title line.\n</code></pre> <p>And now the command help:</p> <pre><code>toolr example echo -h\nUsage: toolr example echo [-h] WHAT\n\nThis is the command description, it can span several lines.\n\nPositional Arguments:\n  WHAT        What to echo.\n\nOptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"usage/#roundup-1","title":"Roundup #1","text":"<p>So far you've seen a few important pieces:</p> <ul> <li><code>command_group</code></li> <li><code>Context</code></li> </ul>"},{"location":"usage/#docstrings","title":"Docstrings","text":"<p>Docstrings are really useful and can greatly improve the CLI UX:</p> <pre><code>\"\"\"\nComplete example.\n\nThe purpose is to provide an extensive usage example, kind if like TDD\n\n| Example | Description |\n|---------|-------------|\n| hello   | Say hello.  |\n| goodbye | Say goodbye.|\n| multiply| Multiply two numbers.|\n\n\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport shutil\nfrom enum import StrEnum\nfrom typing import Annotated\nfrom typing import NoReturn\n\nfrom toolr import Context\nfrom toolr import arg\nfrom toolr import command_group\n\ngroup = command_group(\"example\", title=\"Example\", docstring=__doc__)\n\n\n@group.command\ndef hello(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Say hello.\n\n    This is the long description about the hello command.\n    \"\"\"\n    ctx.info(\"Hello, world!\")\n\n\n@group.command(\"goodbye\")\ndef say_goodbye(ctx: Context, name: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Say goodbye.\n\n    Args:\n        name: Name to say goodbye to. If not provided, defaults to \"world\".\n    \"\"\"\n    if name is None:\n        name = \"world\"\n    ctx.info(f\"Goodbye, {name}!\")\n\n\n@group.command\ndef multiply(ctx: Context, a: int, b: int, verbose: bool = False) -&gt; NoReturn:\n    \"\"\"\n    Multiply two numbers.\n\n    Args:\n        a: First number.\n        b: Second number.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    result = a * b\n    if verbose:\n        ctx.info(f\"{a} * {b} = {result}\")\n    else:\n        ctx.info(result)\n\n\nclass Operation(StrEnum):\n    ADD = \"add\"\n    SUBTRACT = \"subtract\"\n    MULTIPLY = \"multiply\"\n    DIVIDE = \"divide\"\n\n\n@group.command\ndef math(\n    ctx: Context,\n    a: int,\n    b: int,\n    operation: Annotated[Operation, arg(aliases=[\"-o\", \"--op\"])] = Operation.ADD,\n    verbose: bool = False,\n) -&gt; NoReturn:\n    \"\"\"\n    Perform a mathematical operation.\n\n    Args:\n        a: First number.\n        b: Second number.\n        operation: Operation to perform.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    match operation:\n        case Operation.ADD:\n            value = a + b\n            log_msg = f\"{a} + {b} = {value}\"\n        case Operation.SUBTRACT:\n            value = a - b\n            log_msg = f\"{a} - {b} = {value}\"\n        case Operation.MULTIPLY:\n            value = a * b\n            log_msg = f\"{a} * {b} = {value}\"\n        case Operation.DIVIDE:\n            if b == 0:\n                ctx.error(\"Division by zero!\")\n                return\n            value = a / b\n            log_msg = f\"{a} / {b} = {value}\"\n        case _:\n            raise ValueError(f\"Invalid operation: {operation}\")\n    if verbose:\n        ctx.info(log_msg)\n    else:\n        ctx.info(value)\n\n\n@group.command\ndef py_version(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Show Python version.\n\n    This command demonstrates how to run subprocess commands and capture their output.\n    \"\"\"\n    python = shutil.which(\"python\")\n    ret = ctx.run(python, \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", ret.stdout.read().strip())\n</code></pre> <p>It can even render some markdown tables!</p>"},{"location":"usage/#module-help","title":"Module Help","text":"<pre><code>toolr example -h\nUsage: toolr example [-h] {hello,goodbye,multiply,math} ...\n\nComplete example.\n\nOptions:\n  -h, --help            show this help message and exit\n\nExample:\n  The purpose is to provide an extensive usage example, kind if like TDD\n\n    Example    Description\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n    hello      Say hello.\n    goodbye    Say goodbye.\n    multiply   Multiply two numbers.\n\n  {hello,goodbye,multiply,math}\n    hello               Say hello.\n    goodbye             Say goodbye.\n    multiply            Multiply two numbers.\n    math                Perform a mathematical operation.\n</code></pre>"},{"location":"usage/#math-command-help","title":"<code>math</code> command help","text":"<pre><code>toolr example math -h\nUsage: toolr example math [-h] [--operation OPERATION] [--verbose] A B\n\nPerform a mathematical operation.\n\nPositional Arguments:\n  A                     First number.\n  B                     Second number.\n\nOptions:\n  -h, --help            show this help message and exit\n  --operation, -o, --op OPERATION\n                        Operation to perform. Choices: 'add', 'subtract', 'multiply', 'divide'. (default: add)\n  --verbose             Whether to print the result calculation. Defaults to False, print only the result. (default: False)\n</code></pre>"},{"location":"usage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"usage/#third-party-commands","title":"Third-Party Commands","text":"<p>ToolR supports 3rd-party commands from installable Python packages. This allows you to extend ToolR's functionality by installing additional packages that provide their own commands.</p>"},{"location":"usage/#creating-a-3rd-party-package","title":"Creating a 3rd-Party Package","text":"<p>To create a package that contributes commands to ToolR, you need to:</p> <ol> <li>Define your commands using the standard ToolR API</li> <li>Register an entry point in your package's <code>pyproject.toml</code></li> </ol> <p>Here's an example of a 3rd-party package structure:</p> thirdparty/commands.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\nthird_party_group = command_group(\"third-party\", \"Third Party Tools\", \"Tools from third-party packages\")\n\n@third_party_group.command(\"hello\")\ndef hello_command(ctx: Context, name: str = \"World\") -&gt; None:\n    \"\"\"Say hello to someone.\n\n    Args:\n        ctx: The execution context\n        name: Name to greet (default: World)\n    \"\"\"\n    ctx.print(f\"Hello, {name} from 3rd-party package!\")\n\n@third_party_group.command(\"version\")\ndef version_command(ctx: Context) -&gt; None:\n    \"\"\"Show the version of the 3rd-party package.\n\n    Args:\n        ctx: The execution context\n    \"\"\"\n    ctx.print(\"3rd-party package version 1.0.0\")\n</code></pre>"},{"location":"usage/#entry-point-configuration","title":"Entry Point Configuration","text":"<p>In your package's <code>pyproject.toml</code>, define the entry point:</p> <pre><code>[project.entry-points.\"toolr.tools\"]\n&lt;this name is not important&gt; = \"&lt;package&gt;.&lt;module calling toolr.command_group()&gt;\"\n</code></pre> <p>For example:</p> <pre><code>[project.entry-points.\"toolr.tools\"]\ncommands = \"thirdparty.commands\"\n</code></pre>"},{"location":"usage/#installation-and-discovery","title":"Installation and Discovery","text":"<p>Once installed alongside ToolR, the package will automatically contribute its commands. You can see a complete working example in the ToolR repository.</p>"},{"location":"usage/#command-resolution","title":"Command Resolution","text":"<p>When multiple packages provide commands with the same name:</p> <ul> <li>Repository commands (commands defined in your local <code>tools/</code> directory) override 3rd-party commands</li> <li>If the parent command group is shared, 3rd-party commands augment the existing command group</li> </ul> <p>This allows for flexible command composition while maintaining local control over command behavior.</p>"}]}
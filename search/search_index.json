{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Home","text":"In-project CLI tooling support <p> Pronounced /\u02c8tu\u02d0l\u0259r/ (tool-er) </p> <p>ToolR is a tool similar to invoke and the next generation of python-tools-scripts.</p> <p>The goal is to quickly enable projects to write a Python module under the project's <code>tools/</code> sub-directory and it automatically becomes a sub command to the <code>toolr</code> CLI.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automatic-command-discovery","title":"Automatic Command Discovery","text":"<p>ToolR automatically discovers and registers commands from your project's <code>tools/</code> directory, making it easy to organize and maintain your project's CLI tools.</p>"},{"location":"#simple-command-definition","title":"Simple Command Definition","text":"<p>Define commands using simple Python functions with type hints. ToolR automatically generates argument parsing based on your function signatures.</p>"},{"location":"#nested-command-groups","title":"Nested Command Groups","text":"<p>Organize commands into logical groups and subgroups using dot notation, providing a clean and intuitive CLI structure.</p>"},{"location":"#rich-help-system","title":"Rich Help System","text":"<p>Built-in support for rich text formatting and automatic help generation from docstrings and type annotations.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li> <p>Install ToolR:    <pre><code>python -m pip install toolr\n</code></pre></p> </li> <li> <p>Create a tools package in your project root:    <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre></p> </li> <li> <p>Write your first command in <code>tools/example.py</code>:    <pre><code>from toolr import Context, command_group\n\ngroup = registry.command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello to someone.\n\n    Args:\n      name: The name to say hello to.\n    \"\"\"\n    ctx.print(f\"Hello, {name}!\")\n</code></pre></p> </li> <li> <p>Run your command:    <pre><code>toolr example hello --name Alice\n</code></pre></p> </li> </ol>"},{"location":"examples/","title":"Examples","text":"<p>Here's some basic usage examples to start off of.</p>"},{"location":"examples/#simple-command","title":"Simple Command","text":"<p>The most basic command is a function with a context parameter:</p> tools/hello.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"greeting\", \"Greeting Commands\", \"Commands for greeting users\")\n\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello.\n\n    Args:\n        name: The name of the person to greet.\n    \"\"\"\n    ctx.info(\"Hello\", name, \"!\")\n</code></pre> <p>Run with: <pre><code>toolr greeting hello --name Alice\n# Output: Hello, Alice!\n</code></pre></p>"},{"location":"examples/#command-with-multiple-arguments","title":"Command with Multiple Arguments","text":"tools/calculator.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"math\", \"Math Commands\", \"Basic mathematical operations\")\n\n\n@group.command\ndef add(ctx: Context, a: int, b: int):\n    \"\"\"Add two numbers together.\n\n    Args:\n        a: First number.\n        b: Second number.\n    \"\"\"\n    result = a + b\n    ctx.info(f\"{a} + {b} = {result}\")\n    return result\n</code></pre> <p>Run with: <pre><code>toolr math add 5 3\n# Output: 5 + 3 = 8\n</code></pre></p>"},{"location":"examples/#boolean-flags","title":"Boolean Flags","text":"tools/example.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n\n@group.command\ndef process(ctx: Context, verbose: bool = False, dry_run: bool = False):\n    \"\"\"Process something with optional flags.\n\n    Args:\n        verbose: Whether to print verbose output.\n        dry_run: Whether to perform a dry run (no changes will be made).\n    \"\"\"\n    if verbose:\n        ctx.info(\"Verbose mode enabled\")\n\n    if dry_run:\n        ctx.info(\"Dry run mode - no changes will be made\")\n        return\n\n    ctx.info(\"Processing...\")\n</code></pre> <p>Run with: <pre><code>toolr example process --verbose --dry-run\n# Output: Verbose mode enabled\n#         Dry run mode - no changes will be made\n</code></pre></p>"},{"location":"examples/#list-arguments","title":"List Arguments","text":"tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, files: list[str]):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre> <p>Run with: <pre><code>toolr files process-files file1.txt file2.txt file3.txt\n# Output: Processing file1.txt...\n#         Processing file2.txt...\n#         Processing file3.txt...\n</code></pre></p> <p>The above command could also be defined like:</p> tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, *files: str):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre>"},{"location":"examples/#using-the-context","title":"Using the Context","text":"<p>The <code>ctx</code> parameter provides access to useful utilities:</p> tools/system.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"system\", \"System Commands\", \"System operations\")\n\n\n@group.command\ndef info(ctx: Context) -&gt; None:\n    \"\"\"Show system information.\n\n    Displays repository root, Python version, and other system details.\n    \"\"\"\n    # Access the repository root\n    ctx.info(f\"Repository root: {ctx.repo_root}\")\n\n    # Run a command\n    result = ctx.run(\"python\", \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", result.stdout.read().strip())\n\n    # Rich console output formatting available\n    ctx.print(\"[bold green]System info retrieved successfully![/bold green]\")\n\n\n@group.command\ndef check_disk(ctx: Context, path: str = \".\") -&gt; None:\n    \"\"\"Check disk usage for a path.\n\n    Args:\n        path: The path to check disk usage for. Defaults to current directory.\n    \"\"\"\n    # Run command with error handling\n    try:\n        result = ctx.run(\"du\", \"-sh\", path, capture_output=True, stream_output=False)\n        if result.returncode == 0:\n            ctx.print(f\"[green]Disk usage for {path}: {result.stdout.read().strip()}[/green]\")\n        else:\n            ctx.error(f\"Failed to check disk usage: {result.stderr.read().strip()}\")\n    except Exception as e:\n        ctx.error(f\"Error checking disk usage: {e}\")\n\n\n@group.command\ndef network_test(ctx: Context, host: str = \"8.8.8.8\", count: int = 3) -&gt; None:\n    \"\"\"Test network connectivity to a host.\n\n    Args:\n        host: The host to test connectivity to. Defaults to Google's DNS (8.8.8.8).\n        count: Number of ping packets to send. Defaults to 3.\n    \"\"\"\n    ctx.info(f\"Testing connectivity to {host}\")\n\n    result = ctx.run(\"ping\", \"-c\", count, host, capture_output=True, stream_output=False)\n\n    if result.returncode == 0:\n        ctx.print(f\"[green]Network connectivity to {host} is working[/green]\")\n        # Extract ping statistics\n        lines = result.stdout.read().decode().split(\"\\n\")\n        for line in lines:\n            if \"packets transmitted\" in line:\n                ctx.info(f\"Ping statistics: {line.strip()}\")\n    else:\n        ctx.error(f\"Network connectivity to {host} failed\")\n</code></pre> <p>Run with: <pre><code>toolr system info\n</code></pre></p>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> </ul>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>python -m pip install toolr\n</code></pre>"},{"location":"installation/#project-setup","title":"Project Setup","text":"<p>After installation, create a <code>tools/</code> package in your project root:</p> <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre> <p>This directory will contain all your CLI commands. ToolR will automatically discover and register any Python modules in this directory.</p>"},{"location":"installation/#verification","title":"Verification","text":"<p>To verify the installation, run:</p> <p><pre><code>toolr --help\n</code></pre> You should see the ToolR help output with available commands. <pre><code>Usage: toolr [-h] [--version] [--timestamps | --no-timestamps] [--quiet | --debug] [--timeout SECONDS] [--no-output-timeout-secs SECONDS] {} ...\n\nIn-project CLI tooling support\n\nOptions:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n\nLogging:\n  --timestamps, --ts    Add time stamps to logs (default: False)\n  --no-timestamps, --nts\n                        Remove time stamps from logs (default: True)\n  --quiet, -q           Disable logging (default: False)\n  --debug, -d           Show debug messages (default: False)\n\nRun Subprocess Options:\n  These options apply to ctx.run() calls\n\n  --timeout, --timeout-secs SECONDS\n                        Timeout in seconds for the command to finish. (default: None)\n  --no-output-timeout-secs, --nots SECONDS\n                        Timeout if no output has been seen for the provided seconds. (default: None)\n\nCommands:\n  These commands are discovered under `&lt;repo-root&gt;/tools` recursively.\n\n  {}\n\nMore information about ToolR can be found at https://github.com/s0undt3ch/toolr\n</code></pre></p>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development or to use the latest version:</p> <pre><code># Clone the repository\ngit clone https://github.com/s0undt3ch/toolr.git\ncd toolr\n\n# Install in development mode\nuv sync --dev\n</code></pre>"},{"location":"reference/toolr/_context/","title":"toolr._context","text":"<p>This module provides the Context class, which is passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.ConsoleVerbosity","title":"ConsoleVerbosity","text":"<p>               Bases: <code>IntEnum</code></p> <p>Console verbosity levels.</p>"},{"location":"reference/toolr/_context/#toolr._context.ConsoleVerbosity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the console verbosity.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the console verbosity.\n    \"\"\"\n    return self.name.lower()\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context","title":"Context","text":"<p>               Bases: <code>Struct</code></p> <p>Context object passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.Context.print","title":"print","text":"<pre><code>print(*args: ConsoleRenderable | RichCast | str, **kwargs: Any) -&gt; None\n</code></pre> <p>Print to stdout.</p> <p>This is a wrapper around :func:<code>rich.console.Console.print</code>.</p> <p>See :func:<code>rich.console.Console.print</code> for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def print(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print to stdout.\n\n    This is a wrapper around :func:`rich.console.Console.print`.\n\n    See :func:`rich.console.Console.print` for more details.\n    \"\"\"\n    self.console_stdout.print(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.debug","title":"debug","text":"<pre><code>debug(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print debug message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def debug(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print debug message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.VERBOSE:\n        kwargs.update(style=\"log-debug\", _stack_offset=2)\n        self.console.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.info","title":"info","text":"<pre><code>info(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print info message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def info(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print info message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.NORMAL:\n        kwargs.update(style=\"log-info\", _stack_offset=2)\n        self.console.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.warn","title":"warn","text":"<pre><code>warn(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print warning message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def warn(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print warning message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-warning\", _stack_offset=2)\n    self.console.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.error","title":"error","text":"<pre><code>error(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print error message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def error(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print error message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-error\", _stack_offset=2)\n    self.console.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.exit","title":"exit","text":"<pre><code>exit(status: int = 0, message: str | None = None) -&gt; NoReturn\n</code></pre> <p>Exit the command execution.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def exit(self, status: int = 0, message: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Exit the command execution.\n    \"\"\"\n    if message is not None:\n        if status == 0:\n            style = \"exit-ok\"\n        else:\n            style = \"exit-failure\"\n        self.console.print(message, style=style)\n    self.parser.exit(status)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.run","title":"run","text":"<pre><code>run(*cmdline: str, stream_output: bool = True, capture_output: bool = False, timeout_secs: float | None = None, no_output_timeout_secs: float | None = None, **kwargs: Any) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command with the given arguments.</p> <p>This is a wrapper around toolr.utils.command.run that provides a simpler interface for command functions.</p> <p>Parameters:</p> Name Type Description Default <code>cmdline</code> <code>str</code> <p>Command line to run</p> <code>()</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>True</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to toolr.utils.command.run</p> <code>{}</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult instance.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def run(\n    self,\n    *cmdline: str,\n    stream_output: bool = True,\n    capture_output: bool = False,\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n    **kwargs: Any,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"Run a command with the given arguments.\n\n    This is a wrapper around [toolr.utils.command.run][] that provides\n    a simpler interface for command functions.\n\n    Args:\n        cmdline: Command line to run\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n        kwargs: Additional keyword arguments to pass to [toolr.utils.command.run][]\n\n    Returns:\n        CommandResult instance.\n    \"\"\"\n    self.debug(f\"\"\"Running '{\" \".join(cmdline)}'\"\"\")\n    return command.run(\n        cmdline,\n        stream_output=stream_output,\n        capture_output=capture_output,\n        timeout_secs=timeout_secs,\n        no_output_timeout_secs=no_output_timeout_secs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.chdir","title":"chdir","text":"<pre><code>chdir(path: str | Path) -&gt; Iterator[Path]\n</code></pre> <p>Change the working directory for this context.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The new working directory path</p> required <p>Returns:</p> Type Description <code>Iterator[Path]</code> <p>Iterator yielding the new working directory as a Path object</p> <p>This is a context manager, so it should be used with 'with':</p> <p>.. code-block:: python</p> <pre><code>with ctx.chdir(\"/some/path\") as p:\n    # Do something in /some/path\n    # p is the Path object for /some/path\n</code></pre> Source code in <code>python/toolr/_context.py</code> <pre><code>@contextmanager\ndef chdir(self, path: str | pathlib.Path) -&gt; Iterator[pathlib.Path]:\n    \"\"\"Change the working directory for this context.\n\n    Args:\n        path: The new working directory path\n\n    Returns:\n        Iterator yielding the new working directory as a Path object\n\n    This is a context manager, so it should be used with 'with':\n\n    .. code-block:: python\n\n        with ctx.chdir(\"/some/path\") as p:\n            # Do something in /some/path\n            # p is the Path object for /some/path\n    \"\"\"\n    cwd = pathlib.Path.cwd()\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    try:\n        os.chdir(path)\n        yield path\n    finally:\n        if not cwd.exists():\n            self.error(f\"Unable to change back to path {cwd}\")\n        else:\n            os.chdir(cwd)\n</code></pre>"},{"location":"reference/toolr/_exc/","title":"toolr._exc","text":""},{"location":"reference/toolr/_exc/#toolr._exc.ToolrError","title":"ToolrError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Toolr errors.</p>"},{"location":"reference/toolr/_exc/#toolr._exc.SignatureError","title":"SignatureError","text":"<p>               Bases: <code>ToolrError</code></p> <p>Exception raised when a function signature is invalid.</p>"},{"location":"reference/toolr/_parser/","title":"toolr._parser","text":""},{"location":"reference/toolr/_parser/#toolr._parser.Parser","title":"Parser","text":"<p>               Bases: <code>Struct</code></p> <p>Singleton parser class that wraps argparse.</p>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.parse_args","title":"parse_args","text":"<pre><code>parse_args(argv: list[str] | None = None) -&gt; Namespace\n</code></pre> <p>Parse CLI.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def parse_args(self, argv: list[str] | None = None) -&gt; Namespace:\n    \"\"\"\n    Parse CLI.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert self.context is not None\n        assert self.parser is not None\n\n    # Log the argv getting executed\n    self.context.debug(f\"Tools executing 'sys.argv': {sys.argv}\")\n    # Process registered imports to allow other modules to register commands\n    # self._process_registered_tool_modules()\n    options = self.parser.parse_args(argv)\n    verbosity = ConsoleVerbosity.NORMAL\n    if options.quiet:\n        verbosity = ConsoleVerbosity.QUIET\n        logging.root.setLevel(logging.CRITICAL + 1)\n    elif options.debug:\n        verbosity = ConsoleVerbosity.VERBOSE\n        logging.root.setLevel(logging.DEBUG)\n    else:\n        logging.root.setLevel(logging.INFO)\n    if options.timestamps:\n        for handler in logging.root.handlers:\n            handler.setFormatter(_logs.TIMESTAMP_FORMATTER)\n    else:\n        for handler in logging.root.handlers:\n            handler.setFormatter(_logs.NO_TIMESTAMP_FORMATTER)\n\n    # Late import to avoid circular import issues\n    from toolr.utils._console import setup_consoles  # noqa: PLC0415\n\n    # Reset verbosity and consoles after parsing the CLI\n    console, console_stdout = setup_consoles(verbosity)\n    structs.force_setattr(self.context, \"verbosity\", verbosity)\n    structs.force_setattr(self.context, \"console\", console)\n    structs.force_setattr(self.context, \"console_stdout\", console_stdout)\n    if \"func\" not in options:\n        self.context.exit(1, \"No command was passed.\")\n    structs.force_setattr(self, \"options\", options)\n    log.debug(\"CLI parsed options %s\", options)\n    return options\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the command.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the command.\n    \"\"\"\n    if self.options is None:\n        err_msg = \"parser.parse_args() was not called.\"\n        raise RuntimeError(err_msg)\n    self.options.func(self.context, self.options)\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(attr: str) -&gt; Any\n</code></pre> <p>Proxy unknown attributes to the parser instance.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Any:\n    \"\"\"\n    Proxy unknown attributes to the parser instance.\n    \"\"\"\n    if attr == \"options\":\n        return self.__getattribute__(attr)\n    return getattr(self.parser, attr)\n</code></pre>"},{"location":"reference/toolr/_registry/","title":"toolr._registry","text":""},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup","title":"CommandGroup","text":"<p>               Bases: <code>Struct</code></p> <p>A group of commands under a common namespace.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Get the full dot-notation name of this command group.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command","title":"command","text":"<pre><code>command(name: F) -&gt; F\n</code></pre><pre><code>command(name: str) -&gt; Callable[[F], F]\n</code></pre> <pre><code>command(name: str | F) -&gt; Callable[[F], F] | F\n</code></pre> <p>Register a new command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | F</code> <p>Name of the command. If not passed, the function name will be used.</p> required <p>Returns:</p> Type Description <code>Callable[[F], F] | F</code> <p>A decorator function that registers the command</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command(self, name: str | F) -&gt; Callable[[F], F] | F:\n    \"\"\"Register a new command.\n\n    Args:\n        name: Name of the command. If not passed, the function name will be used.\n\n    Returns:\n        A decorator function that registers the command\n    \"\"\"\n    if isinstance(name, FunctionType):\n        # If we were not passed a name in the decorator call, we're being called with a function\n        # and we need to use the function name as the command name\n        return self.command(name.__name__)(name)\n\n    if TYPE_CHECKING:\n        assert isinstance(name, str)\n\n    def decorator(func: F) -&gt; F:\n        self.registry._pending_commands.append((self.full_name, name, func))  # noqa: SLF001\n        return func\n\n    return decorator\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command_group","title":"command_group","text":"<pre><code>command_group(name: str, title: str, description: str | None = None, long_description: str | None = None, docstring: str | None = None) -&gt; CommandGroup\n</code></pre> <p>Create a nested command group within this group.</p> <p>This is a wrapper around the CommandRegistry.command_group method that passes this group's full name as the parent.</p> <p>See command_group for more details.</p> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    self,\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Create a nested command group within this group.\n\n    This is a wrapper around the [CommandRegistry.command_group][toolr._registry.CommandRegistry.command_group]\n    method that passes this group's full name as the parent.\n\n    See [command_group][toolr._registry.CommandRegistry.command_group] for more details.\n\n    Returns:\n        A CommandGroup instance\n    \"\"\"\n    return self.registry.command_group(\n        name,\n        title,\n        description=description,\n        parent=self.full_name,\n        long_description=long_description,\n        docstring=docstring,\n    )\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry","title":"CommandRegistry","text":"<p>               Bases: <code>Struct</code></p> <p>Registry for CLI commands and their subcommands.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.parser","title":"parser  <code>property</code>","text":"<pre><code>parser: Parser\n</code></pre> <p>Get the parser for this registry.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.command_group","title":"command_group","text":"<pre><code>command_group(name: str, title: str, description: str | None = None, long_description: str | None = None, docstring: str | None = None, parent: str | None = None) -&gt; CommandGroup\n</code></pre> <p>Register a new command group.</p> <p>If you pass <code>docstring</code>, you won't be allowed to pass <code>description</code> or <code>long_description</code>. Those will be parsed by docstring-parser. The first line of the docstring will be used as the description, the rest will be used as the long description.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the command group</p> required <code>title</code> <code>str</code> <p>Title for the command group</p> required <code>description</code> <code>str | None</code> <p>Description for the command group</p> <code>None</code> <code>long_description</code> <code>str | None</code> <p>Long description for the command group</p> <code>None</code> <code>docstring</code> <code>str | None</code> <p>Docstring for the command group</p> <code>None</code> <code>parent</code> <code>str | None</code> <p>Optional parent command path using dot notation (e.g. \"tools.docker.build\")</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    self,\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n    parent: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Register a new command group.\n\n    If you pass ``docstring``, you won't be allowed to pass ``description`` or ``long_description``.\n    Those will be parsed by [docstring-parser](https://pypi.org/project/docstring-parser/).\n    The first line of the docstring will be used as the description, the rest will be used as the long description.\n\n    Args:\n        name: Name of the command group\n        title: Title for the command group\n        description: Description for the command group\n        long_description: Long description for the command group\n        docstring: Docstring for the command group\n        parent: Optional parent command path using dot notation (e.g. \"tools.docker.build\")\n\n    Returns:\n        A CommandGroup instance\n\n    \"\"\"\n    if parent is None:\n        parent = \"tools\"\n\n    if docstring is not None:\n        if description is not None or long_description is not None:\n            err_msg = \"You can't pass both docstring and description or long_description\"\n            raise ValueError(err_msg)\n        parsed_docstring = parse_docstring(docstring)\n        description = parsed_docstring.short_description\n        long_description = parsed_docstring.long_description\n    elif description is None:\n        err_msg = \"You must at least pass either the 'docstring' or 'description' argument\"\n        raise ValueError(err_msg)\n\n    if TYPE_CHECKING:\n        assert description is not None\n\n    # Create the command group\n    group = CommandGroup(\n        name=name,\n        title=title,\n        description=description,\n        registry=self,\n        parent=parent,\n        long_description=long_description,\n    )\n\n    # Store the command group for later parser building\n    self._command_groups[group.full_name] = group\n    return group\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.discover_and_build","title":"discover_and_build","text":"<pre><code>discover_and_build(parser: Parser | None = None) -&gt; None\n</code></pre> <p>Discover all commands and build the parser hierarchy.</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def discover_and_build(self, parser: Parser | None = None) -&gt; None:\n    \"\"\"Discover all commands and build the parser hierarchy.\"\"\"\n    if parser is not None:\n        self._set_parser(parser)\n    self._discover_commands()\n    self._build_parsers()\n</code></pre>"},{"location":"reference/toolr/utils/_console/","title":"toolr.utils._console","text":""},{"location":"reference/toolr/utils/_docstrings/","title":"toolr.utils._docstrings","text":""},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.parse_docstring","title":"parse_docstring","text":"<pre><code>parse_docstring(docstring: str) -&gt; Docstring\n</code></pre> <p>Parse a docstring into a Docstring object.</p> Source code in <code>python/toolr/utils/_docstrings.py</code> <pre><code>def parse_docstring(docstring: str) -&gt; Docstring:\n    \"\"\"Parse a docstring into a Docstring object.\"\"\"\n    parser = GoogleParser()\n    parse_docstring = parser.parse(docstring)\n    short_description = parse_docstring.short_description\n    long_description = parse_docstring.long_description or short_description\n\n    if TYPE_CHECKING:\n        assert short_description is not None\n        assert long_description is not None\n\n    params = {param.arg_name: param.description for param in parse_docstring.params}\n    return Docstring(\n        short_description=short_description,\n        long_description=long_description,\n        params=params,\n    )\n</code></pre>"},{"location":"reference/toolr/utils/_logs/","title":"toolr.utils._logs","text":""},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.DuplicateTimesFormatter","title":"DuplicateTimesFormatter","text":"<pre><code>DuplicateTimesFormatter(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>Formatter</code></p> <p>Formatter that adds a timestamp to the message, if it's not a duplicate.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    super().__init__(*args, **kwargs)\n    self._last_timestamp: str | None = None\n</code></pre>"},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.include_timestamps","title":"include_timestamps","text":"<pre><code>include_timestamps() -&gt; bool\n</code></pre> <p>Return True if any of the configured logging handlers includes timestamps.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def include_timestamps() -&gt; bool:\n    \"\"\"\n    Return True if any of the configured logging handlers includes timestamps.\n    \"\"\"\n    return any(handler.formatter is TIMESTAMP_FORMATTER for handler in logging.root.handlers)\n</code></pre>"},{"location":"reference/toolr/utils/_signature/","title":"toolr.utils._signature","text":"<p>Utilities to parse function signatures.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.VarArg","title":"VarArg","text":"<p>               Bases: <code>Arg</code>, <code>Struct</code></p> <p>VarArg is a special case of Arg that is used to represent a variable number of arguments.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.arg","title":"arg","text":"<pre><code>arg(*, aliases: list[str] | None = None, required: bool | None = None, metavar: str | None = None, action: str | None = None, choices: list[Any] | None = None, nargs: NargsType | None = None) -&gt; ArgumentAnnotation\n</code></pre> <p>Create an ArgumentAnnotation.</p> <p>This function is meant to be used with :class:<code>typing.Annotated</code> to create an ArgumentAnnotation.</p> <p>Parameters:</p> Name Type Description Default <code>aliases</code> <code>list[str] | None</code> <p>Aliases for the argument.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Whether the argument is required.</p> <code>None</code> <code>metavar</code> <code>str | None</code> <p>The metavar for the argument.</p> <code>None</code> <code>action</code> <code>str | None</code> <p>The action for the argument.</p> <code>None</code> <code>choices</code> <code>list[Any] | None</code> <p>The choices for the argument.</p> <code>None</code> <code>nargs</code> <code>NargsType | None</code> <p>The number of arguments to accept.</p> <code>None</code> Source code in <code>python/toolr/utils/_signature.py</code> <pre><code>def arg(\n    *,\n    aliases: list[str] | None = None,\n    required: bool | None = None,\n    metavar: str | None = None,\n    action: str | None = None,\n    choices: list[Any] | None = None,\n    nargs: NargsType | None = None,\n) -&gt; ArgumentAnnotation:\n    \"\"\"\n    Create an ArgumentAnnotation.\n\n    This function is meant to be used with :class:`typing.Annotated` to create an ArgumentAnnotation.\n\n    Args:\n        aliases: Aliases for the argument.\n        required: Whether the argument is required.\n        metavar: The metavar for the argument.\n        action: The action for the argument.\n        choices: The choices for the argument.\n        nargs: The number of arguments to accept.\n    \"\"\"\n    return ArgumentAnnotation(\n        aliases=aliases, required=required, metavar=metavar, action=action, choices=choices, nargs=nargs\n    )\n</code></pre>"},{"location":"reference/toolr/utils/command/","title":"toolr.utils.command","text":"<p>Public interface to the rust command extension module.</p> <p>It provides a simple interface to run commands and stream/capture their output.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.CommandResult","title":"CommandResult","text":"<p>               Bases: <code>Struct</code>, <code>Generic[T]</code></p> <p>The result of a command execution.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.run","title":"run","text":"<pre><code>run(args: Sequence[str], *, cwd: str | Path | None = None, env: ENVIRON = None, input: str | bytes | None = None, stream_output: bool = False, capture_output: bool = False, text: bool = True, encoding: str | None = 'utf-8', timeout_secs: float | None = None, no_output_timeout_secs: float | None = None) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command in a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str]</code> <p>Command and arguments to run</p> required <code>cwd</code> <code>str | Path | None</code> <p>Current working directory to run the command in. Defaults to the current directory.</p> <code>None</code> <code>env</code> <code>ENVIRON</code> <p>Environment variables to pass to the command</p> <code>None</code> <code>input</code> <code>str | bytes | None</code> <p>Input data to pass to the command</p> <code>None</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>False</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>text</code> <code>bool</code> <p>Whether to return output as text or bytes</p> <code>True</code> <code>encoding</code> <code>str | None</code> <p>Encoding to use for text output</p> <code>'utf-8'</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult object containing stdout, stderr, and return code</p> <p>Raises:</p> Type Description <code>CommandError</code> <p>If any of the pre-run checks fail or an operational failure happens.</p> <code>CommandTimeoutError</code> <p>If the command times out</p> <code>CommandTimeoutNoOutputError</code> <p>If the command produces no output for too long</p> Source code in <code>python/toolr/utils/command.py</code> <pre><code>def run(  # noqa: PLR0915\n    args: Sequence[str],\n    *,\n    cwd: str | pathlib.Path | None = None,\n    env: ENVIRON = None,\n    input: str | bytes | None = None,  # noqa: A002\n    stream_output: bool = False,\n    capture_output: bool = False,\n    text: bool = True,\n    encoding: str | None = \"utf-8\",\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"\n    Run a command in a subprocess.\n\n    Args:\n        args: Command and arguments to run\n        cwd: Current working directory to run the command in. Defaults to the current directory.\n        env: Environment variables to pass to the command\n        input: Input data to pass to the command\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        text: Whether to return output as text or bytes\n        encoding: Encoding to use for text output\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n\n    Returns:\n        CommandResult object containing stdout, stderr, and return code\n\n    Raises:\n        CommandError: If any of the pre-run checks fail or an operational failure happens.\n        CommandTimeoutError: If the command times out\n        CommandTimeoutNoOutputError: If the command produces no output for too long\n    \"\"\"\n    # Stream output is only supported with text=True\n    if stream_output and not text:\n        err_msg = \"stream_output=True requires text=True\"\n        raise ValueError(err_msg)\n\n    if cwd is None:\n        cwd = pathlib.Path.cwd()\n\n    # Initialize file variables with explicit types\n    stdout_file: IO[Any] | None = None\n    stderr_file: IO[Any] | None = None\n    stdout_fd: int | None = None\n    stderr_fd: int | None = None\n    sys_stdout_fd: int | None = None\n    sys_stderr_fd: int | None = None\n\n    try:\n        # Process the input data\n        input_bytes = None\n        if input is not None:\n            if isinstance(input, str):\n                input_bytes = input.encode(encoding or \"utf-8\")\n            else:\n                input_bytes = input\n\n        # Prepare environment\n        env_dict: dict[str, str] = {}\n        if env:\n            env_dict.update(env)\n        else:\n            # If no environment provided, inherit the current environment\n            env_dict.update(os.environ)\n\n        # Set up stdout/stderr handling\n        if capture_output:\n            if text:\n                stdout_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n            else:\n                stdout_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n\n            stdout_fd = stdout_file.fileno()\n            stderr_fd = stderr_file.fileno()\n\n        # Get sys.stdout and sys.stderr file descriptors if streaming\n        if stream_output:\n            try:\n                sys_stdout_fd = sys.stdout.fileno()\n                sys_stderr_fd = sys.stderr.fileno()\n            except io.UnsupportedOperation:\n                if TYPE_CHECKING:\n                    assert sys.__stdout__ is not None\n                    assert sys.__stderr__ is not None\n\n                sys_stdout_fd = sys.__stdout__.fileno()\n                sys_stderr_fd = sys.__stderr__.fileno()\n\n        # Run the command implementation\n        command_args = list(args)\n        returncode = run_command_impl(\n            command_args,\n            cwd=str(cwd),\n            env=env_dict,\n            input=input_bytes,\n            stdout_fd=stdout_fd,\n            stderr_fd=stderr_fd,\n            sys_stdout_fd=sys_stdout_fd,\n            sys_stderr_fd=sys_stderr_fd,\n            timeout_secs=timeout_secs,\n            no_output_timeout_secs=no_output_timeout_secs,\n        )\n\n        if TYPE_CHECKING:\n            assert stdout_file is not None\n            assert stderr_file is not None\n\n        # Rewind files for reading\n        if stdout_file:\n            stdout_file.seek(0)\n        if stderr_file:\n            stderr_file.seek(0)\n\n        # Return the result with correct typing\n        if text is True:\n            return cast(\n                \"CommandResult[str]\",\n                CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n            )\n        return cast(\n            \"CommandResult[bytes]\",\n            CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n        )\n\n    except Exception as exc:  # noqa: BLE001\n        # Clean up on error\n        if stdout_file and hasattr(stdout_file, \"close\"):\n            stdout_file.close()\n        if stderr_file and hasattr(stderr_file, \"close\"):\n            stderr_file.close()\n\n        # Re-raise the exception\n        raise exc from None\n</code></pre>"},{"location":"usage/","title":"How to use","text":"<p>It's important to note that ToolR relies on proper typing of the python functions that will become commands. If fact, it will complain and error out if typing information is missing or unable to parse.</p> <p>It's also important to note that the function must also have a properly written docstring using google style docstrings.</p> <pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", title=\"Example\", description=\"Example commands\")\n\n\n@group.command\ndef echo(ctx: Context, what: str):\n    \"\"\"\n    Command title line.\n\n    This is the command description, it can span several lines.\n\n    Args:\n        what: What to echo.\n    \"\"\"\n    ctx.print(what)\n</code></pre> <p>Let's see it!</p> <pre><code>toolr example -h\nUsage: toolr example [-h] {echo} ...\n\nExample commands\n\nOptions:\n  -h, --help  show this help message and exit\n\nExample:\n  Example commands\n\n  {echo}\n    echo      Command title line.\n</code></pre> <p>And now the command help:</p> <pre><code>toolr example echo -h\nUsage: toolr example echo [-h] WHAT\n\nThis is the command description, it can span several lines.\n\nPositional Arguments:\n  WHAT        What to echo.\n\nOptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"usage/#roundup-1","title":"Roundup #1","text":"<p>So far you've seen a few important pieces:</p> <ul> <li><code>command_group</code></li> <li><code>Context</code></li> </ul>"},{"location":"usage/#docstrings","title":"Docstrings","text":"<p>Docstrings are really useful and can greatly improve the CLI UX:</p> <pre><code>\"\"\"\nComplete example.\n\nThe purpose is to provide an extensive usage example, kind if like TDD\n\n| Example | Description |\n|---------|-------------|\n| hello   | Say hello.  |\n| goodbye | Say goodbye.|\n| multiply| Multiply two numbers.|\n\n\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport shutil\nfrom enum import StrEnum\nfrom typing import Annotated\nfrom typing import NoReturn\n\nfrom toolr import Context\nfrom toolr import arg\nfrom toolr import registry\n\ncommand_group = registry.command_group(\"example\", title=\"Example\", docstring=__doc__)\n\n\n@command_group.command\ndef hello(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Say hello.\n\n    This is the long description about the hello command.\n    \"\"\"\n    ctx.info(\"Hello, world!\")\n\n\n@command_group.command(\"goodbye\")\ndef say_goodbye(ctx: Context, name: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Say goodbye.\n\n    Args:\n        name: Name to say goodbye to. If not provided, defaults to \"world\".\n    \"\"\"\n    if name is None:\n        name = \"world\"\n    ctx.info(f\"Goodbye, {name}!\")\n\n\n@command_group.command\ndef multiply(ctx: Context, a: int, b: int, verbose: bool = False) -&gt; NoReturn:\n    \"\"\"\n    Multiply two numbers.\n\n    Args:\n        a: First number.\n        b: Second number.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    result = a * b\n    if verbose:\n        ctx.info(f\"{a} * {b} = {result}\")\n    else:\n        ctx.info(result)\n\n\nclass Operation(StrEnum):\n    ADD = \"add\"\n    SUBTRACT = \"subtract\"\n    MULTIPLY = \"multiply\"\n    DIVIDE = \"divide\"\n\n\n@command_group.command\ndef math(\n    ctx: Context,\n    a: int,\n    b: int,\n    operation: Annotated[Operation, arg(aliases=[\"-o\", \"--op\"])] = Operation.ADD,\n    verbose: bool = False,\n) -&gt; NoReturn:\n    \"\"\"\n    Perform a mathematical operation.\n\n    Args:\n        a: First number.\n        b: Second number.\n        operation: Operation to perform.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    match operation:\n        case Operation.ADD:\n            value = a + b\n            log_msg = f\"{a} + {b} = {value}\"\n        case Operation.SUBTRACT:\n            value = a - b\n            log_msg = f\"{a} - {b} = {value}\"\n        case Operation.MULTIPLY:\n            value = a * b\n            log_msg = f\"{a} * {b} = {value}\"\n        case Operation.DIVIDE:\n            value = a / b\n            log_msg = f\"{a} / {b} = {value}\"\n        case _:\n            raise ValueError(f\"Invalid operation: {operation}\")\n    if verbose:\n        ctx.info(log_msg)\n    else:\n        ctx.info(value)\n\n\n@command_group.command\ndef py_version(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Print the Python version.\n    \"\"\"\n    python = shutil.which(\"python\")\n    ret = ctx.run(python, \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", ret.stdout.read().strip())\n</code></pre> <p>It can even render some markdown tables!</p>"},{"location":"usage/#module-help","title":"Module Help","text":"<pre><code>toolr example -h\nUsage: toolr example [-h] {hello,goodbye,multiply,math} ...\n\nComplete example.\n\nOptions:\n  -h, --help            show this help message and exit\n\nExample:\n  The purpose is to provide an extensive usage example, kind if like TDD\n\n    Example    Description\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n    hello      Say hello.\n    goodbye    Say goodbye.\n    multiply   Multiply two numbers.\n\n  {hello,goodbye,multiply,math}\n    hello               Say hello.\n    goodbye             Say goodbye.\n    multiply            Multiply two numbers.\n    math                Perform a mathematical operation.\n</code></pre>"},{"location":"usage/#math-command-help","title":"<code>math</code> command help","text":"<pre><code>toolr example math -h\nUsage: toolr example math [-h] [--operation OPERATION] [--verbose] A B\n\nPerform a mathematical operation.\n\nPositional Arguments:\n  A                     First number.\n  B                     Second number.\n\nOptions:\n  -h, --help            show this help message and exit\n  --operation, -o, --op OPERATION\n                        Operation to perform. Choices: 'add', 'subtract', 'multiply', 'divide'. (default: add)\n  --verbose             Whether to print the result calculation. Defaults to False, print only the result. (default: False)\n</code></pre>"}]}
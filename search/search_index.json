{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"],"fields":{"title":{"boost":1000.0},"text":{"boost":1.0},"tags":{"boost":1000000.0}}},"docs":[{"location":"","title":"Home","text":"In-project CLI tooling support <p> Pronounced /\u02c8tu\u02d0l\u0259r/ (tool-er) </p> <p>ToolR is a tool similar to invoke and the next generation of python-tools-scripts.</p> <p>The goal is to quickly enable projects to write a Python module under the project's <code>tools/</code> sub-directory and it automatically becomes a sub command to the <code>toolr</code> CLI.</p>"},{"location":"#key-features","title":"Key Features","text":""},{"location":"#automatic-command-discovery","title":"Automatic Command Discovery","text":"<p>ToolR automatically discovers and registers commands from your project's <code>tools/</code> directory, making it easy to organize and maintain your project's CLI tools.</p>"},{"location":"#simple-command-definition","title":"Simple Command Definition","text":"<p>Define commands using simple Python functions with type hints. ToolR automatically generates argument parsing based on your function signatures.</p>"},{"location":"#nested-command-groups","title":"Nested Command Groups","text":"<p>Organize commands into logical groups and subgroups using dot notation, providing a clean and intuitive CLI structure.</p>"},{"location":"#rich-help-system","title":"Rich Help System","text":"<p>Built-in support for rich text formatting and automatic help generation from docstrings and type annotations.</p>"},{"location":"#third-party-command-support","title":"Third-Party Command Support","text":"<p>Extend ToolR's functionality by installing packages that provide additional commands through Python entry points.</p>"},{"location":"#quick-start","title":"Quick Start","text":"<ol> <li>Install ToolR:</li> </ol> <pre><code>python -m pip install toolr\n</code></pre> <ol> <li>Create a tools package in your project root:</li> </ol> <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre> <ol> <li>Write your first command in <code>tools/example.py</code>:</li> </ol> <pre><code>from toolr import Context, command_group\n\ngroup = command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello to someone.\n\n    Args:\n      name: The name to say hello to.\n    \"\"\"\n    ctx.print(f\"Hello, {name}!\")\n</code></pre> <ol> <li>Run your command:</li> </ol> <pre><code>toolr example hello --name Alice\n</code></pre>"},{"location":"#advanced-usage","title":"Advanced Usage","text":""},{"location":"#third-party-commands","title":"Third-Party Commands","text":"<p>ToolR supports 3rd-party commands from installable Python packages. Create packages that extend ToolR's functionality by defining commands and registering them as entry points.</p> <p>See the Advanced Topics section in the documentation for detailed information about creating 3rd-party command packages.</p>"},{"location":"#testing-and-security","title":"Testing and Security","text":"<p>ToolR includes comprehensive testing with a focus on security and robustness:</p>"},{"location":"#property-based-testing-fuzzing","title":"Property-Based Testing (Fuzzing)","text":"<p>ToolR uses Hypothesis for property-based testing to automatically discover edge cases and potential vulnerabilities. Fuzzing tests are integrated into the regular test suite:</p> <p>```bash</p>"},{"location":"#run-all-tests-including-fuzzing-tests","title":"Run all tests (including fuzzing tests)","text":"<p>uv run pytest</p>"},{"location":"#run-only-fuzzing-tests","title":"Run only fuzzing tests","text":"<p>uv run pytest -k \"test_fuzz\"</p>"},{"location":"changelog/","title":"Changelog","text":"<p>All notable changes to this project will be documented in this file.</p> <p>This project uses git-cliff to automatically generate changelog entries from Conventional Commits, and this project adheres to Semantic Versioning.</p>"},{"location":"changelog/#0110dev98-2025-12-24","title":"0.11.0.dev98 - 2025-12-24","text":""},{"location":"changelog/#features","title":"\ud83d\ude80 Features","text":"<ul> <li>(logs) Include extra keywords in logs output (<code>695dc58</code>)</li> <li>(tests) Fuzzy testing (<code>f34c9cd</code>)</li> <li>(security) Add <code>SECURITY.md</code> file (<code>131b75a</code>)</li> </ul>"},{"location":"changelog/#bug-fixes","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(pypi) We can't have local version parts in PyPi (<code>fa3c515</code>)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(release) Update ToolR action versions in workflows (<code>0d11014</code>)</li> <li>(ci) Switch to prek (<code>64c5997</code>)</li> <li>(pre-commit) Update pre-commit hook versions (<code>6438077</code>)</li> <li>(ci) Switch to <code>macos-15-intel</code> to build Intel wheels (<code>211b0fa</code>)</li> <li>(ci) Lock permissions on the build.yml workflow (<code>aabe4e5</code>)</li> <li>(ci) Lock <code>build.yml</code> GitHub Actions to SHA hashes (<code>08bdda3</code>)</li> <li>(ci) Only run attestations on the main repo (<code>0d2b361</code>)</li> <li>(ci) Improve <code>cibuildwheel`` build performance by adding cache ([</code>60a438f`](https://github.com/s0undt3ch/ToolR/commit/60a438f5c00b406f170ff7d07e4ac9968984c967))</li> <li>(ci) Fix the chicken &amp; egg issue with releases. (<code>77cc4f6</code>)</li> <li>(ci) Remove no longer required process (<code>821592f</code>)</li> <li>(ci) Update but still lock to the SHA (<code>57e3719</code>)</li> <li>(ci) When updating our own usage or toolr in GH Actions, lock it (<code>b666088</code>)</li> <li>(ci) Restrict GH Actions jobs permissions (<code>14bfc6d</code>)</li> <li>(pre-commit) Add pre-commit hook to lock GH Actions steps (<code>5d69b7a</code>)</li> <li>(ci) Switch <code>prepare-release</code> to a reusable workflow (<code>9e6c657</code>)</li> <li>(ci) Update actions versions (<code>2faf97c</code>)</li> <li>(ci) Fix auto version bump (<code>2a85e6c</code>)</li> <li>(docs) Add CONTRIBUTING document (<code>7691338</code>)</li> </ul>"},{"location":"changelog/#new-contributors","title":"New Contributors","text":"<ul> <li>@step-security-bot made their first contribution</li> </ul>"},{"location":"changelog/#0110-2025-09-24","title":"0.11.0 - 2025-09-24","text":""},{"location":"changelog/#features_1","title":"\ud83d\ude80 Features","text":"<ul> <li>(docstrings) We now use a rust extension to parse the docstrings (<code>a2744f0</code>)</li> <li>(commands help) The command's help message is now formatted with Markdown (<code>d786915</code>)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_1","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(sync-rolling-tags) Fix <code>sync-rolling-tags</code> workflow trigger (<code>889e36f</code>)</li> <li>(ci) Sync'ing rolling tags is now done on demand (<code>773745b</code>)</li> <li>(ci) Fix sync-rolling-tags command (<code>59c2955</code>)</li> <li>(ci) More fixes to the sync-rolling-tags process (<code>45ac806</code>)</li> <li>(release) Update ToolR action versions in workflows (<code>6cc4bde</code>)</li> <li>(ci) Final sync-rolling-tags fix (<code>c48fcbe</code>)</li> <li>(ci) Refresh some caches (<code>a91de3d</code>)</li> </ul>"},{"location":"changelog/#0101-2025-09-19","title":"0.10.1 - 2025-09-19","text":""},{"location":"changelog/#bug-fixes_1","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(parent) Fix command nesting (<code>c223dfc</code>)</li> <li>(command) We now log the <code>.run()</code> cmdline at the <code>INFO</code> level (<code>1311f8d</code>)</li> <li>(tests) Fix <code>ctx.which</code> tests to make them less brittle. (<code>8a55cf3</code>)</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_2","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(release) Don't update ToolR action usage in workflows (<code>fbe4992</code>)</li> <li>(release) Add workflow that updates ToolR versions in workflows (<code>9782974</code>)</li> </ul>"},{"location":"changelog/#0100-2025-09-17","title":"0.10.0 - 2025-09-17","text":""},{"location":"changelog/#miscellaneous-tasks_3","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(ci) Improve CI build matrix reporting (<code>777595c</code>)</li> <li>(ci) Prevent unnecessary branch builds on PRs (<code>4d7e911</code>)</li> <li>(release) Update all self ToolR actions usage on release (<code>38e2a8b</code>)</li> <li>(ci) Consistent workflow toolr output width (<code>4475406</code>)</li> </ul>"},{"location":"changelog/#090-2025-09-13","title":"0.9.0 - 2025-09-13","text":""},{"location":"changelog/#features_2","title":"\ud83d\ude80 Features","text":"<ul> <li>(cli) Provide a <code>Context</code> class</li> <li>(registry) Implemented the registry and it's tests</li> <li>(logging) Add <code>toolr.utils.logs</code> to improve logging support</li> <li>(cli) Provide the package CLI entry point</li> <li>(help) We now use <code>RichHelpFormatter</code> to render the help</li> <li>(docstrings) Parse docstrings to construct help</li> <li>(docs) Capture each parameter description from docstrings</li> <li>(coverage) Upload code coverage to codecov</li> <li>(ci) Upload test results to codecov</li> <li>(signatures) Add signature parsing</li> <li>(signature) Handle append action, including weird boolean append.</li> <li>(nargs) Support <code>nargs</code> and <code>*variable</code> in function signatures</li> <li>(docs) Documentation!</li> <li>(context) Implemented prompt support in <code>Context</code>.</li> <li>(github-actions) Allow setting ToolR from a github-action</li> <li>(signature) Add support for mutually exclusive groups</li> <li>(logging) Add <code>setup_logging</code> function.</li> </ul>"},{"location":"changelog/#bug-fixes_2","title":"\ud83d\udc1b Bug Fixes","text":"<ul> <li>(imports) Handle import errors when searching for tools</li> <li>(descriptions) Differentiate descriptions</li> <li>(docstring) Fix dosctring class reference</li> <li>(decorator) Fix decorator usage.</li> <li>(help) Parse each decorated command docstring to provide help</li> <li>(log) Only log the time on specific occasions.</li> <li>(tests) Fix tests according to latest code changes</li> <li>(tests) Fix rust tests on windows</li> <li>(scope) Let the codecov CLI tool find the coverage files</li> <li>(coverage) Don't track coverage in <code>if TYPE_CHECKING:</code> code blocks</li> <li>(signature) <code>dest</code> is always set to the name of the positional parameter</li> <li>(tests) Small refactor to improve testing</li> <li>(signature) On positional arguments, the name will always be the first alias</li> <li>(enums) Handle enums by name instead of by value</li> <li>(cli) Fix early verbose/debug output CLI parsing logic</li> <li>(tests) Skip problematic windows test</li> <li>(docs) Include missing docs examples</li> <li>(docs) Remove <code>uv run</code> prefix from examples</li> <li>(command) Command names from functions auto-naming</li> <li>(SignatureError) <code>SignatureError</code> exceptions now point to command</li> <li>(pypi) Fix PyPi packaging uploads</li> </ul>"},{"location":"changelog/#refactor","title":"\ud83d\ude9c Refactor","text":"<ul> <li>(toolr) Support 3rd-party commands</li> <li>(consoles) Name context consoles explicitly</li> <li>(3rd-party) Fix commands and command groups augment/overrides</li> <li>(consoles) Refactor consoles setup</li> </ul>"},{"location":"changelog/#miscellaneous-tasks_4","title":"\u2699\ufe0f Miscellaneous Tasks","text":"<ul> <li>(dependencies) Add <code>rich=-argparse</code> as a dependency</li> <li>(command) Rename <code>command.run_command</code> to <code>command.run</code></li> <li>(context) Make the <code>context</code> module \"private\".</li> <li>(ci) Define allowed concurrency</li> <li>(requiremenst) We no longer need to maintain separate requirements files</li> <li>(tools) Clean up the pre-existing tools directory</li> <li>(pre-commit) Update pre-commit hook versions</li> <li>(lint) Fix lint issues found with latest pre-commit hooks versions</li> <li>(cibuildweel) Bump <code>MACOSX_DEPLOYMENT_TARGET</code> to <code>11.0</code></li> <li>(cleanup) Remove <code>changelog.d/</code>, it won't be needed anymore</li> <li>(typing) Make the typing gods happier</li> <li>(msgspec) Replaced all usages of <code>dataclass</code> with <code>msgspec.Struct</code></li> <li>(pre-commit) Upgrade some pre-commit hooks</li> <li>(pre-commit) Add <code>codespell</code> pre-commit hook</li> <li>(parser) Use a private method to set the parser instead.</li> <li>(discovery) Actually start discovering tools when running <code>toolr</code></li> <li>(typing) Fix typing</li> <li>(samples) Fix sample cases to respect the required signature</li> <li>(rust) Address clippy errors</li> <li>(ci) Define the pre-commit cache to be inside the workspace</li> <li>(ci) Parallelize package builds</li> <li>(ci) Use OIDC to authenticate codecov</li> <li>(tests) Add default pytest flags to config</li> <li>(dependencies) Add <code>pytest-subtests</code> to dev dependencies</li> <li>(tests) Add <code>argv</code> tests</li> <li>(logs) Logging utils module testing</li> <li>(tests) Add test coverage for the <code>__main__</code> module</li> <li>(tests) Improve test coverage of the context object</li> <li>(README.md) Fix logo file path</li> <li>(mypy) Have mypy ignore <code>tests/support/3rd-party-pkg/.*</code></li> <li>(tests) Add test coverage to <code>setup_consoles</code></li> <li>(pyproject.toml) Define the 3rd-party test package as editable</li> <li>(ci) Improved parallelization</li> <li>(pre-commit) Update hook versions</li> <li>(tests) Split <code>tests/test_context.py</code> into several test modules</li> <li>(docs) Add <code>ruff</code> as a docs dependency</li> <li>(ci) Add and use <code>.github/actions/setup-virtualenv</code></li> <li>(ci) Push built packages to test.pypi.org on the default branch</li> <li>(docs) Fix logo URL in readme</li> <li>(gitignore) Ignore <code>*.code-workspace</code></li> <li>(pre-commit) Upgrade pre-commit hook versions</li> <li>(ConsoleVerbosity) Move <code>ConsoleVerbosity</code> to  <code>toolr.utils._console</code></li> <li>(action) Simplify action</li> <li>(release) Update the release process</li> <li>(release) Separate release workflow</li> <li>(security) Include build provenance attestations</li> <li>(debug) Set verbose to true when running in debug mode</li> <li>(oackages) Stop building for <code>s390x</code>.</li> <li>(dependabot) Add <code>dependabot</code> configuration</li> <li>(docs) Add <code>.readthedocs.yaml</code> config file</li> <li>(release) Fix attestations on release workflow</li> <li>(release) Fix generate build matrix step</li> <li>(changelog) Add cliff config file</li> <li>(release) More release workflow fixes</li> <li>(release) Use the global permissions</li> <li>(release) Use GH App to push the tags</li> <li>(release) The action now just configures git with higher privileges</li> <li>(release) Just repeat, it's simpler in the end</li> <li>(release) Use <code>sdist</code> to build wheels</li> <li>(release) Prepare for 0.1.1 release</li> <li>(release) Publish GH release fixes</li> <li>(release) Prepare for 0.1.2 release</li> <li>(release) Change release notes filename name</li> <li>(docs) Update the docs URL to  the right one</li> <li>(release) Remove the PyPi url</li> <li>(release) Revert debug release changes</li> <li>(release) Fix package name to be compliant with PyPi</li> <li>(changelog) Fix white-space issues around changelog generation</li> <li>(prepare-release) Run <code>pre-commit</code> against the prepare release changes</li> <li>(ci) Pre-commit needs to be setup and run in a few places</li> </ul>"},{"location":"changelog/#new-contributors_1","title":"New Contributors","text":"<ul> <li>@s0undt3ch-gh-actions-automations[bot] made their first contribution</li> <li>@dependabot[bot] made their first contribution</li> </ul>"},{"location":"contributing/","title":"Contributing to ToolR","text":"<p>First off, thank you for considering contributing to ToolR! It's people like you that make ToolR such a great tool.</p>"},{"location":"contributing/#table-of-contents","title":"Table of Contents","text":"<ul> <li>Code of Conduct</li> <li>Getting Started</li> <li>Development Setup</li> <li>How to Contribute</li> <li>Pull Request Process</li> <li>Coding Standards</li> <li>Testing Guidelines</li> <li>Commit Message Guidelines</li> <li>Security</li> <li>Development Workflow</li> <li>Code Review Guidelines</li> </ul>"},{"location":"contributing/#code-of-conduct","title":"Code of Conduct","text":"<p>This project and everyone participating in it is governed by respect, professionalism, and inclusivity. By participating, you are expected to uphold these values. Please report unacceptable behavior by opening a GitHub Issue or contacting the project maintainers.</p>"},{"location":"contributing/#our-standards","title":"Our Standards","text":"<p>Positive behaviors include:</p> <ul> <li>Using welcoming and inclusive language</li> <li>Being respectful of differing viewpoints and experiences</li> <li>Gracefully accepting constructive criticism</li> <li>Focusing on what is best for the community</li> <li>Showing empathy towards other community members</li> </ul> <p>Unacceptable behaviors include:</p> <ul> <li>Trolling, insulting/derogatory comments, and personal or political attacks</li> <li>Public or private harassment</li> <li>Publishing others' private information without explicit permission</li> <li>Other conduct which could reasonably be considered inappropriate in a professional setting</li> </ul>"},{"location":"contributing/#getting-started","title":"Getting Started","text":""},{"location":"contributing/#prerequisites","title":"Prerequisites","text":"<p>Before contributing, make sure you have:</p> <ul> <li>Python 3.11+ installed</li> <li>Rust toolchain (for building native extensions)</li> <li>mise - Development environment manager</li> <li>gh CLI (optional, for GitHub Actions utilities)</li> <li>git for version control</li> </ul>"},{"location":"contributing/#first-time-contributors","title":"First-time Contributors","text":"<p>New to open source? Here are some resources:</p> <ul> <li>How to Contribute to Open Source</li> <li>First Timers Only</li> <li>GitHub's Guide to Contributing</li> </ul> <p>Look for issues labeled <code>good first issue</code> or <code>help wanted</code>.</p>"},{"location":"contributing/#development-setup","title":"Development Setup","text":""},{"location":"contributing/#1-fork-and-clone","title":"1. Fork and Clone","text":"<pre><code># Fork the repository on GitHub, then clone your fork\ngit clone https://github.com/YOUR_USERNAME/ToolR.git\ncd ToolR\n\n# Add upstream remote\ngit remote add upstream https://github.com/s0undt3ch/ToolR.git\n</code></pre>"},{"location":"contributing/#2-install-mise","title":"2. Install mise","text":"<p>mise manages our development environment, including Python, Rust, and other tools (see https://mise.jdx.dev/getting-started.html).</p> <pre><code>curl https://mise.run | sh\n\n# Install project tools\nmise install\n\n# Activate the environment\nmise activate\n</code></pre> <p>This will automatically:</p> <ul> <li>Install the correct Python version</li> <li>Install the Rust toolchain</li> <li>Install uv package manager</li> <li>Set up other project dependencies</li> </ul>"},{"location":"contributing/#3-install-dependencies","title":"3. Install Dependencies","text":"<pre><code># Sync Python dependencies and create virtual environment\nuv sync --all-extras --dev\n</code></pre>"},{"location":"contributing/#4-install-prek-pre-commit-hooks","title":"4. Install prek (Pre-commit Hooks)","text":"<p>We use prek instead of standard pre-commit:</p> <pre><code># Install prek hooks\nprek install --install-hooks\n</code></pre>"},{"location":"contributing/#5-verify-setup","title":"5. Verify Setup","text":"<pre><code># Run tests\nuv run pytest\n\n# Run all pre-commit checks\nprek run --all-files\n</code></pre>"},{"location":"contributing/#how-to-contribute","title":"How to Contribute","text":""},{"location":"contributing/#reporting-bugs","title":"Reporting Bugs","text":"<p>GitHub Issues are used for bug tracking. Before creating a bug report:</p> <ul> <li>Search existing issues to avoid duplicates</li> <li>Use the latest version of ToolR</li> <li>Collect information about your environment</li> </ul> <p>When filing a bug report, include:</p> <ul> <li>Clear title and description</li> <li>Steps to reproduce the issue</li> <li>Expected vs actual behavior</li> <li>Environment details (OS, Python version, ToolR version)</li> <li>Error messages (full stack traces)</li> <li>Screenshots if applicable</li> </ul> <p>Create a new issue to report bugs.</p>"},{"location":"contributing/#suggesting-enhancements","title":"Suggesting Enhancements","text":"<p>Feature requests are also tracked as GitHub Issues. When creating an enhancement suggestion:</p> <ul> <li>Use a clear title describing the enhancement</li> <li>Provide a detailed description of the proposed functionality</li> <li>Explain why this would be useful to most ToolR users</li> <li>List examples of how the enhancement would be used</li> <li>Note any alternatives you've considered</li> </ul> <p>Create a new issue to suggest features.</p>"},{"location":"contributing/#pull-requests","title":"Pull Requests","text":"<p>GitHub Pull Requests are used for code contributions. Follow the pull request process below.</p>"},{"location":"contributing/#your-first-code-contribution","title":"Your First Code Contribution","text":"<ol> <li>Find an issue to work on (or create one)</li> <li>Comment on the issue to let others know you're working on it</li> <li>Create a branch from <code>main</code>:</li> </ol> <pre><code>git checkout -b feature/your-feature-name\n# or\ngit checkout -b fix/your-bug-fix\n</code></pre> <ol> <li>Make your changes following our coding standards</li> <li>Write/update tests to cover your changes</li> <li>Run the test suite to ensure nothing breaks</li> <li>Commit your changes with descriptive messages</li> <li>Push to your fork and submit a pull request</li> </ol>"},{"location":"contributing/#pull-request-process","title":"Pull Request Process","text":""},{"location":"contributing/#before-submitting","title":"Before Submitting","text":"<ul> <li>[ ] Run all tests and ensure they pass</li> <li>[ ] Run prek to check linting, formatting, and types</li> <li>[ ] Update documentation if needed</li> <li>[ ] Add tests for new functionality</li> <li>[ ] Ensure commits follow our commit message guidelines</li> <li>[ ] Rebase on latest main if needed</li> </ul> <p>Note: Do NOT manually update <code>CHANGELOG.md</code> - it's automatically generated from commit messages using git-cliff.</p>"},{"location":"contributing/#submitting","title":"Submitting","text":"<ol> <li>Push your branch to your fork</li> <li>Open a pull request against the <code>main</code> branch</li> <li>Write a clear PR description:</li> <li>What changes were made</li> <li>Why the changes are needed</li> <li>Any breaking changes</li> <li>Link related issues (e.g., \"Closes #123\")</li> <li>Respond to feedback and update as needed</li> </ol>"},{"location":"contributing/#pr-review-process","title":"PR Review Process","text":"<ul> <li>Maintainers will review your PR within a few days</li> <li>You may be asked to make changes</li> <li>Once approved, maintainers will merge your PR</li> <li>Your contribution will be included in the next release!</li> </ul>"},{"location":"contributing/#ci-checks","title":"CI Checks","text":"<p>All PRs must pass:</p> <ul> <li>\u2705 Tests (pytest on Linux/macOS/Windows)</li> <li>\u2705 Linting (ruff, via prek)</li> <li>\u2705 Type checking (mypy, via prek)</li> <li>\u2705 Formatting (ruff format, via prek)</li> <li>\u2705 Rust checks (cargo clippy, cargo check, via prek)</li> <li>\u2705 GitHub Actions (actionlint, via prek)</li> <li>\u2705 Shell scripts (shellcheck, via prek)</li> <li>\u2705 Security (CodeQL, dependency review)</li> <li>\u2705 Spelling (codespell, typos, via prek)</li> <li>\u2705 Markdown (markdownlint, via prek)</li> <li>\u2705 Documentation (builds without errors)</li> </ul> <p>All these checks run automatically via prek hooks and CI.</p>"},{"location":"contributing/#coding-standards","title":"Coding Standards","text":""},{"location":"contributing/#python-code","title":"Python Code","text":"<ul> <li>Follow PEP 8 for style (enforced by ruff)</li> <li>Use type hints for all function signatures</li> <li>Use <code>from __future__ import annotations</code> at the top of files</li> <li>Maximum line length: 120 characters</li> <li>Use ruff for linting and formatting (automated by prek)</li> <li>Use mypy for type checking (automated by prek)</li> </ul> <pre><code>from __future__ import annotations\n\nfrom typing import Any\n\ndef greet(name: str, *, enthusiastic: bool = False) -&gt; str:\n    \"\"\"Greet someone by name.\n\n    Args:\n        name: The name of the person to greet.\n        enthusiastic: Whether to add extra enthusiasm.\n\n    Returns:\n        A greeting message.\n    \"\"\"\n    greeting = f\"Hello, {name}\"\n    return f\"{greeting}!\" if enthusiastic else greeting\n</code></pre>"},{"location":"contributing/#rust-code","title":"Rust Code","text":"<ul> <li>Follow Rust style guidelines</li> <li>Use <code>cargo fmt</code> for formatting (automated by prek)</li> <li>Use <code>cargo clippy</code> for linting (automated by prek)</li> <li>Write doc comments for public APIs</li> <li>Add tests for new functionality</li> </ul> <pre><code>/// Greet someone by name.\n///\n/// # Arguments\n///\n/// * `name` - The name of the person to greet\n///\n/// # Returns\n///\n/// A greeting message\npub fn greet(name: &amp;str) -&gt; String {\n    format!(\"Hello, {}\", name)\n}\n</code></pre>"},{"location":"contributing/#documentation","title":"Documentation","text":"<ul> <li>Use Google-style docstrings for Python</li> <li>Use Rustdoc for Rust code</li> <li>Include examples in docstrings</li> <li>Update docs/ when adding features</li> <li>Keep README.md up to date</li> </ul>"},{"location":"contributing/#pre-commit-hooks","title":"Pre-commit Hooks","text":"<p>All formatting and linting is handled automatically by prek:</p> <pre><code># Run all checks\nprek run --all-files\n\n# Run specific hook\nprek run ruff-format\n\n# Bypass hooks (use sparingly!)\ngit commit --no-verify\n</code></pre>"},{"location":"contributing/#testing-guidelines","title":"Testing Guidelines","text":""},{"location":"contributing/#writing-tests","title":"Writing Tests","text":"<ul> <li>Write tests for all new functionality</li> <li>Update tests when changing behavior</li> <li>Test edge cases and error conditions</li> <li>Use descriptive test names</li> <li>Keep tests focused (one concept per test)</li> </ul>"},{"location":"contributing/#running-tests","title":"Running Tests","text":"<pre><code># Run all tests\nuv run pytest\n\n# Run specific test file\nuv run pytest tests/test_version.py\n\n# Run with coverage\nuv run coverage run -m pytest\nuv run coverage report\n\n# Run Rust tests\ncargo test\n\n# Run specific Rust test\ncargo test test_name\n</code></pre>"},{"location":"contributing/#test-organization","title":"Test Organization","text":"<pre><code>tests/\n\u251c\u2500\u2500 cli/                 # CLI argument parsing tests\n\u251c\u2500\u2500 context/             # Context and runtime tests\n\u251c\u2500\u2500 parser/              # Parser tests\n\u251c\u2500\u2500 registry/            # Command discovery and registry tests\n\u251c\u2500\u2500 utils/               # Utility function tests\n\u251c\u2500\u2500 support/             # Test fixtures and support files\n\u251c\u2500\u2500 conftest.py          # Shared fixtures\n\u2514\u2500\u2500 test_*.py            # Additional test modules\n</code></pre>"},{"location":"contributing/#property-based-testing","title":"Property-Based Testing","text":"<p>ToolR uses Hypothesis for property-based testing (fuzzing):</p> <pre><code>from hypothesis import given\nfrom hypothesis import strategies as st\n\n@given(st.text())\ndef test_handles_any_input(text: str) -&gt; None:\n    \"\"\"Test that the function handles any text input.\"\"\"\n    result = process_text(text)\n    assert isinstance(result, str)\n</code></pre>"},{"location":"contributing/#commit-message-guidelines","title":"Commit Message Guidelines","text":"<p>We follow Conventional Commits for clear commit history and automated changelogs.</p>"},{"location":"contributing/#format","title":"Format","text":"<pre><code>&lt;type&gt;(&lt;scope&gt;): &lt;subject&gt;\n\n&lt;body&gt;\n\n&lt;footer&gt;\n</code></pre>"},{"location":"contributing/#types","title":"Types","text":"<ul> <li>feat: New feature</li> <li>fix: Bug fix</li> <li>docs: Documentation changes</li> <li>style: Code style changes (formatting, etc.)</li> <li>refactor: Code refactoring</li> <li>perf: Performance improvements</li> <li>test: Adding or updating tests</li> <li>build: Build system changes</li> <li>ci: CI configuration changes</li> <li>chore: Other changes (dependencies, etc.)</li> </ul>"},{"location":"contributing/#examples","title":"Examples","text":"<pre><code>feat(cli): add --verbose flag for detailed output\n\nAdd a --verbose flag to enable detailed logging output.\nThis helps users debug issues with command execution.\n\nCloses #123\n\n---\n\nfix(version): correct git describe pattern for multi-digit versions\n\nThe pattern v[0-9].[0-9].[0-9] only matched single digits.\nChanged to v[0-9]*.[0-9]*.[0-9]* to support versions like v0.11.0.\n\nFixes #456\n\n---\n\ndocs: update contributing guidelines with commit conventions\n</code></pre>"},{"location":"contributing/#breaking-changes","title":"Breaking Changes","text":"<p>For breaking changes, add <code>BREAKING CHANGE:</code> in the footer:</p> <pre><code>feat(api)!: remove deprecated get_version function\n\nBREAKING CHANGE: The get_version() function has been removed.\nUse version.current() instead.\n</code></pre>"},{"location":"contributing/#why-conventional-commits","title":"Why Conventional Commits?","text":"<ul> <li>Automated changelog generation using git-cliff</li> <li>Semantic versioning automation</li> <li>Clear history for understanding project evolution</li> <li>Better collaboration through standardized messages</li> </ul>"},{"location":"contributing/#security","title":"Security","text":""},{"location":"contributing/#reporting-vulnerabilities","title":"Reporting Vulnerabilities","text":"<p>DO NOT open a public issue for security vulnerabilities.</p> <p>Instead, use GitHub Security Advisories to privately report security issues.</p> <p>See our Security Policy for more details.</p>"},{"location":"contributing/#security-best-practices","title":"Security Best Practices","text":"<p>When contributing:</p> <ul> <li>Never commit secrets (API keys, passwords, tokens)</li> <li>Pin action versions to commit SHAs in workflows</li> <li>Validate user input to prevent injection attacks</li> <li>Use secure defaults in configurations</li> <li>Review dependencies for known vulnerabilities</li> </ul>"},{"location":"contributing/#development-workflow","title":"Development Workflow","text":""},{"location":"contributing/#branch-naming","title":"Branch Naming","text":"<ul> <li><code>feature/description</code> - New features</li> <li><code>fix/description</code> - Bug fixes</li> <li><code>docs/description</code> - Documentation updates</li> <li><code>refactor/description</code> - Code refactoring</li> <li><code>test/description</code> - Test additions/updates</li> </ul>"},{"location":"contributing/#daily-development","title":"Daily Development","text":"<pre><code># Update your fork\ngit checkout main\ngit pull upstream main\ngit push origin main\n\n# Create feature branch\ngit checkout -b feature/my-feature\n\n# Make changes, commit often\ngit add .\ngit commit -m \"feat: add my feature\"\n\n# Run checks before pushing\nprek run --all-files\n\n# Push to your fork\ngit push origin feature/my-feature\n\n# Open a pull request on GitHub\n</code></pre>"},{"location":"contributing/#keeping-your-branch-updated","title":"Keeping Your Branch Updated","text":"<pre><code># Fetch latest changes\ngit fetch upstream\n\n# Rebase your branch\ngit rebase upstream/main\n\n# Force push if already pushed\ngit push --force-with-lease origin feature/my-feature\n</code></pre>"},{"location":"contributing/#code-review-guidelines","title":"Code Review Guidelines","text":""},{"location":"contributing/#for-contributors","title":"For Contributors","text":"<ul> <li>Respond promptly to review feedback</li> <li>Ask questions if feedback is unclear</li> <li>Make requested changes or explain why not</li> <li>Mark conversations as resolved when addressed</li> <li>Be respectful and professional</li> </ul>"},{"location":"contributing/#for-reviewers","title":"For Reviewers","text":"<ul> <li>Review thoroughly but constructively</li> <li>**Provide specific feedback</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>Here's some basic usage examples to start off of.</p>"},{"location":"examples/#simple-command","title":"Simple Command","text":"<p>The most basic command is a function with a context parameter:</p> tools/hello.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"greeting\", \"Greeting Commands\", \"Commands for greeting users\")\n\n\n@group.command\ndef hello(ctx: Context, name: str = \"World\"):\n    \"\"\"Say hello.\n\n    Args:\n        name: The name of the person to greet.\n    \"\"\"\n    ctx.info(\"Hello\", name, \"!\")\n</code></pre> <p>Run with:</p> <pre><code>toolr greeting hello --name Alice\n# Output: Hello, Alice!\n</code></pre>"},{"location":"examples/#command-with-multiple-arguments","title":"Command with Multiple Arguments","text":"tools/calculator.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"math\", \"Math Commands\", \"Basic mathematical operations\")\n\n\n@group.command\ndef add(ctx: Context, a: int, b: int):\n    \"\"\"Add two numbers together.\n\n    Args:\n        a: First number.\n        b: Second number.\n    \"\"\"\n    result = a + b\n    ctx.info(f\"{a} + {b} = {result}\")\n    return result\n</code></pre> <p>Run with:</p> <pre><code>toolr math add 5 3\n# Output: 5 + 3 = 8\n</code></pre>"},{"location":"examples/#boolean-flags","title":"Boolean Flags","text":"tools/example.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", \"Example Commands\", \"Example command group\")\n\n\n@group.command\ndef process(ctx: Context, verbose: bool = False, dry_run: bool = False):\n    \"\"\"Process something with optional flags.\n\n    Args:\n        verbose: Whether to print verbose output.\n        dry_run: Whether to perform a dry run (no changes will be made).\n    \"\"\"\n    if verbose:\n        ctx.info(\"Verbose mode enabled\")\n\n    if dry_run:\n        ctx.info(\"Dry run mode - no changes will be made\")\n        return\n\n    ctx.info(\"Processing...\")\n</code></pre> <p>Run with:</p> <pre><code>toolr example process --verbose --dry-run\n# Output: Verbose mode enabled\n#         Dry run mode - no changes will be made\n</code></pre>"},{"location":"examples/#list-arguments","title":"List Arguments","text":"tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, files: list[str]):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre> <p>Run with:</p> <pre><code>toolr files process-files file1.txt file2.txt file3.txt\n# Output: Processing file1.txt...\n#         Processing file2.txt...\n#         Processing file3.txt...\n</code></pre> <p>The above command could also be defined like:</p> tools/files.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"files\", \"File Commands\", \"File operations\")\n\n\n@group.command\ndef process_files(ctx: Context, *files: str):\n    \"\"\"Process multiple files.\n\n    Args:\n        files: The files to process.\n    \"\"\"\n    for file in files:\n        ctx.info(f\"Processing {file}...\")\n</code></pre>"},{"location":"examples/#using-the-context","title":"Using the Context","text":"<p>The <code>ctx</code> parameter provides access to useful utilities:</p> tools/system.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"system\", \"System Commands\", \"System operations\")\n\n\n@group.command\ndef info(ctx: Context) -&gt; None:\n    \"\"\"Show system information.\n\n    Displays repository root, Python version, and other system details.\n    \"\"\"\n    # Access the repository root\n    ctx.info(f\"Repository root: {ctx.repo_root}\")\n\n    # Run a command\n    result = ctx.run(\"python\", \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", result.stdout.read().strip())\n\n    # Rich console output formatting available\n    ctx.print(\"[bold green]System info retrieved successfully![/bold green]\")\n\n\n@group.command\ndef check_disk(ctx: Context, path: str = \".\") -&gt; None:\n    \"\"\"Check disk usage for a path.\n\n    Args:\n        path: The path to check disk usage for. Defaults to current directory.\n    \"\"\"\n    # Run command with error handling\n    try:\n        result = ctx.run(\"du\", \"-sh\", path, capture_output=True, stream_output=False)\n        if result.returncode == 0:\n            ctx.print(f\"[green]Disk usage for {path}: {result.stdout.read().strip()}[/green]\")\n        else:\n            ctx.error(f\"Failed to check disk usage: {result.stderr.read().strip()}\")\n    except Exception as e:\n        ctx.error(f\"Error checking disk usage: {e}\")\n\n\n@group.command\ndef network_test(ctx: Context, host: str = \"8.8.8.8\", count: int = 3) -&gt; None:\n    \"\"\"Test network connectivity to a host.\n\n    Args:\n        host: The host to test connectivity to. Defaults to Google's DNS (8.8.8.8).\n        count: Number of ping packets to send. Defaults to 3.\n    \"\"\"\n    ctx.info(f\"Testing connectivity to {host}\")\n\n    result = ctx.run(\"ping\", \"-c\", count, host, capture_output=True, stream_output=False)\n\n    if result.returncode == 0:\n        ctx.print(f\"[green]Network connectivity to {host} is working[/green]\")\n        # Extract ping statistics\n        lines = result.stdout.read().decode().split(\"\\n\")\n        for line in lines:\n            if \"packets transmitted\" in line:\n                ctx.info(f\"Ping statistics: {line.strip()}\")\n    else:\n        ctx.error(f\"Network connectivity to {host} failed\")\n</code></pre> <p>Run with:</p> <pre><code>toolr system info\n</code></pre>"},{"location":"examples/#function-name-conversion","title":"Function Name Conversion","text":"<p>ToolR automatically converts Python function names with underscores to command names with hyphens:</p> tools/function_names.py<pre><code>\"\"\"Example demonstrating function name to command name conversion.\n\nThis example shows how function names with underscores are automatically converted\nto command names with hyphens when using the @command decorator without specifying\na name.\n\"\"\"\n\nfrom __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\n# Create a command group\ntools = command_group(\n    \"names\",\n    \"Examples for function name to command name conversion\",\n    \"Various examples for function name to command name conversion\",\n)\n\n\n# Define commands using function names - they will be automatically converted\n@tools.command\ndef simple_function(ctx: Context) -&gt; None:  # -&gt; simple-function\n    \"\"\"A simple function.\"\"\"\n\n\n@tools.command\ndef function_with_underscores(ctx: Context) -&gt; None:  # -&gt; function-with-underscores\n    \"\"\"A function with underscores in the name.\"\"\"\n\n\n@tools.command\ndef multiple_underscores_in_name(ctx: Context) -&gt; None:  # -&gt; multiple-underscores-in-name\n    \"\"\"A function with multiple underscores.\"\"\"\n\n\n@tools.command\ndef _leading_underscore(ctx: Context) -&gt; None:  # -&gt; -leading-underscore\n    \"\"\"A function with a leading underscore.\"\"\"\n\n\n@tools.command\ndef trailing_underscore_(ctx: Context) -&gt; None:  # -&gt; trailing-underscore-\n    \"\"\"A function with a trailing underscore.\"\"\"\n\n\n@tools.command\ndef _both_underscores_(ctx: Context) -&gt; None:  # -&gt; -both-underscores-\n    \"\"\"A function with both leading and trailing underscores.\"\"\"\n</code></pre> <p>This example demonstrates how function names like <code>function_with_underscores</code> become command names like <code>function-with-underscores</code> in the CLI.</p> <pre><code>toolr names -h\nUsage: toolr names [-h] {simple-function,function-with-underscores,multiple-underscores-in-name,-leading-underscore,trailing-underscore-,-both-underscores-} ...\n\nVarious examples for function name to command name conversion\n\nOptions:\n  -h, --help            show this help message and exit\n\nExamples For Function Name To Command Name Conversion:\n  Various examples for function name to command name conversion\n\n  {simple-function,function-with-underscores,multiple-underscores-in-name,-leading-underscore,trailing-underscore-,-both-underscores-}\n    simple-function     A simple function.\n    function-with-underscores\n                        A function with underscores in the name.\n    multiple-underscores-in-name\n                        A function with multiple underscores.\n    -leading-underscore\n                        A function with a leading underscore.\n    trailing-underscore-\n                        A function with a trailing underscore.\n    -both-underscores-  A function with both leading and trailing underscores.\n</code></pre>"},{"location":"installation/","title":"Installation","text":""},{"location":"installation/#requirements","title":"Requirements","text":"<ul> <li>Python 3.11 or higher</li> </ul>"},{"location":"installation/#using-pip","title":"Using pip","text":"<pre><code>python -m pip install toolr\n</code></pre>"},{"location":"installation/#project-setup","title":"Project Setup","text":"<p>After installation, create a <code>tools/</code> package in your project root:</p> <pre><code>mkdir tools\ntouch tools/__init__.py\n</code></pre> <p>This directory will contain all your CLI commands. ToolR will automatically discover and register any Python modules in this directory.</p>"},{"location":"installation/#verification","title":"Verification","text":"<p>To verify the installation, run:</p> <pre><code>toolr --help\n</code></pre> <p>You should see the ToolR help output with available commands.</p> <pre><code>Usage: toolr [-h] [--version] [--timestamps | --no-timestamps] [--quiet | --debug] [--timeout SECONDS] [--no-output-timeout-secs SECONDS] {} ...\n\nIn-project CLI tooling support\n\nOptions:\n  -h, --help            show this help message and exit\n  --version             show program's version number and exit\n\nLogging:\n  --timestamps, --ts    Add time stamps to logs (default: False)\n  --no-timestamps, --nts\n                        Remove time stamps from logs (default: True)\n  --quiet, -q           Disable logging (default: False)\n  --debug, -d           Show debug messages (default: False)\n\nRun Subprocess Options:\n  These options apply to ctx.run() calls\n\n  --timeout, --timeout-secs SECONDS\n                        Timeout in seconds for the command to finish. (default: None)\n  --no-output-timeout-secs, --nots SECONDS\n                        Timeout if no output has been seen for the provided seconds. (default: None)\n\nCommands:\n  These commands are discovered under `&lt;repo-root&gt;/tools` recursively.\n\n  {}\n\nMore information about ToolR can be found at https://github.com/s0undt3ch/toolr\n</code></pre>"},{"location":"installation/#development-installation","title":"Development Installation","text":"<p>For development or to use the latest version:</p> <pre><code># Clone the repository\ngit clone https://github.com/s0undt3ch/toolr.git\ncd toolr\n\n# Install in development mode\nuv sync --dev\n</code></pre>"},{"location":"installation/#third-party-command-packages","title":"Third-Party Command Packages","text":"<p>ToolR supports 3rd-party command packages that extend its functionality. These packages are automatically discovered when installed alongside ToolR.</p> <p>To install a 3rd-party command package:</p> <pre><code>python -m pip install &lt;package-name&gt;\n</code></pre> <p>The package's commands will be automatically available in the ToolR CLI. See the Advanced Topics section for information about creating your own 3rd-party command packages.</p>"},{"location":"reference/toolr/_context/","title":"toolr._context","text":"<p>This module provides the Context class, which is passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.Context","title":"Context","text":"<p>               Bases: <code>Struct</code></p> <p>Context object passed to every command group function as the first argument.</p>"},{"location":"reference/toolr/_context/#toolr._context.Context.prompt","title":"prompt","text":"<pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[bool],\n    *,\n    default: bool | None = None,\n    show_default: bool = True,\n) -&gt; bool\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[str],\n    *,\n    password: bool = True,\n    default: str | None = None,\n    case_sensitive: bool = True,\n) -&gt; str\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[int],\n    *,\n    choices: list[str] | None = None,\n    default: int | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; int\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[float],\n    *,\n    choices: list[str] | None = None,\n    default: float | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; float\n</code></pre><pre><code>prompt(\n    prompt: TextType,\n    expected_type: None = None,\n    *,\n    choices: list[str] | None = None,\n    default: None = None,\n    case_sensitive: bool = True,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str\n</code></pre> <pre><code>prompt(\n    prompt: TextType,\n    expected_type: type[str | int | float | bool]\n    | None = None,\n    *,\n    password: bool = False,\n    case_sensitive: bool = True,\n    choices: list[str] | None = None,\n    default: str | int | float | bool | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str | int | float | bool\n</code></pre> <p>Prompt the user for input.</p> <p>This is a wrapper around rich.prompt.Prompt.ask.</p> <p>See rich.prompt.Prompt.ask for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def prompt(\n    self,\n    prompt: TextType,\n    expected_type: type[str | int | float | bool] | None = None,\n    *,\n    password: bool = False,\n    case_sensitive: bool = True,\n    choices: list[str] | None = None,\n    default: str | int | float | bool | None = None,\n    show_default: bool = True,\n    show_choices: bool = True,\n) -&gt; str | int | float | bool:\n    \"\"\"\n    Prompt the user for input.\n\n    This is a wrapper around [rich.prompt.Prompt.ask][rich.prompt].\n\n    See [rich.prompt.Prompt.ask][rich.prompt] for more details.\n    \"\"\"\n    return self._prompt(\n        prompt,\n        expected_type,\n        password=password,\n        case_sensitive=case_sensitive,\n        choices=choices,\n        default=default,\n        show_default=show_default,\n        show_choices=show_choices,\n    )\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.print","title":"print","text":"<pre><code>print(\n    *args: ConsoleRenderable | RichCast | str, **kwargs: Any\n) -&gt; None\n</code></pre> <p>Print to stdout.</p> <p>This is a wrapper around :func:<code>rich.console.Console.print</code>.</p> <p>See :func:<code>rich.console.Console.print</code> for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def print(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print to stdout.\n\n    This is a wrapper around :func:`rich.console.Console.print`.\n\n    See :func:`rich.console.Console.print` for more details.\n    \"\"\"\n    self._console_stdout.print(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.debug","title":"debug","text":"<pre><code>debug(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print debug message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def debug(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print debug message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.VERBOSE:\n        kwargs.update(style=\"log-debug\", _stack_offset=2)\n        self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.info","title":"info","text":"<pre><code>info(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print info message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def info(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print info message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    if self.verbosity &gt;= ConsoleVerbosity.NORMAL:\n        kwargs.update(style=\"log-info\", _stack_offset=2)\n        self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.warn","title":"warn","text":"<pre><code>warn(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print warning message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def warn(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print warning message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-warning\", _stack_offset=2)\n    self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.error","title":"error","text":"<pre><code>error(*args: Any, **kwargs: Any) -&gt; None\n</code></pre> <p>Print error message to stderr.</p> <p>This is a wrapper around rich.console.Console.log.</p> <p>See rich.console.Console.log for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def error(self, *args: Any, **kwargs: Any) -&gt; None:\n    \"\"\"\n    Print error message to stderr.\n\n    This is a wrapper around [rich.console.Console.log][rich.console.Console.log].\n\n    See [rich.console.Console.log][rich.console.Console.log] for more details.\n    \"\"\"\n    kwargs.update(style=\"log-error\", _stack_offset=2)\n    self._console_stderr.log(*args, **kwargs)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.exit","title":"exit","text":"<pre><code>exit(\n    status: int = 0, message: str | None = None\n) -&gt; NoReturn\n</code></pre> <p>Exit the command execution.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def exit(self, status: int = 0, message: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Exit the command execution.\n    \"\"\"\n    if message is not None:\n        if status == 0:\n            style = \"exit-ok\"\n        else:\n            style = \"exit-failure\"\n        self._console_stderr.print(message, style=style)\n    self.parser.exit(status)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.run","title":"run","text":"<pre><code>run(\n    *cmdline: str,\n    stream_output: bool = True,\n    capture_output: bool = False,\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n    **kwargs: Any,\n) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command with the given arguments.</p> <p>This is a wrapper around toolr.utils.command.run that provides a simpler interface for command functions.</p> <p>Parameters:</p> Name Type Description Default <code>cmdline</code> <code>str</code> <p>Command line to run</p> <code>()</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>True</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <code>kwargs</code> <code>Any</code> <p>Additional keyword arguments to pass to toolr.utils.command.run</p> <code>{}</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult instance.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def run(\n    self,\n    *cmdline: str,\n    stream_output: bool = True,\n    capture_output: bool = False,\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n    **kwargs: Any,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"Run a command with the given arguments.\n\n    This is a wrapper around [toolr.utils.command.run][] that provides\n    a simpler interface for command functions.\n\n    Args:\n        cmdline: Command line to run\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n        kwargs: Additional keyword arguments to pass to [toolr.utils.command.run][]\n\n    Returns:\n        CommandResult instance.\n    \"\"\"\n    self.info(f\"\"\"Running '{\" \".join(cmdline)}'\"\"\")\n    return command.run(\n        cmdline,\n        stream_output=stream_output,\n        capture_output=capture_output,\n        timeout_secs=timeout_secs,\n        no_output_timeout_secs=no_output_timeout_secs,\n        **kwargs,\n    )\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.chdir","title":"chdir","text":"<pre><code>chdir(path: str | Path) -&gt; Iterator[Path]\n</code></pre> <p>Change the working directory for this context.</p> <p>Parameters:</p> Name Type Description Default <code>path</code> <code>str | Path</code> <p>The new working directory path</p> required <p>Returns:</p> Type Description <code>Iterator[Path]</code> <p>Iterator yielding the new working directory as a Path object</p> <p>This is a context manager, so it should be used with 'with':</p> <p>.. code-block:: python</p> <pre><code>with ctx.chdir(\"/some/path\") as p:\n    # Do something in /some/path\n    # p is the Path object for /some/path\n</code></pre> Source code in <code>python/toolr/_context.py</code> <pre><code>@contextmanager\ndef chdir(self, path: str | pathlib.Path) -&gt; Iterator[pathlib.Path]:\n    \"\"\"Change the working directory for this context.\n\n    Args:\n        path: The new working directory path\n\n    Returns:\n        Iterator yielding the new working directory as a Path object\n\n    This is a context manager, so it should be used with 'with':\n\n    .. code-block:: python\n\n        with ctx.chdir(\"/some/path\") as p:\n            # Do something in /some/path\n            # p is the Path object for /some/path\n    \"\"\"\n    cwd = pathlib.Path.cwd()\n    if isinstance(path, str):\n        path = pathlib.Path(path)\n    try:\n        os.chdir(path)\n        yield path\n    finally:\n        if not cwd.exists():\n            self.error(f\"Unable to change back to path {cwd}\")\n        else:\n            os.chdir(cwd)\n</code></pre>"},{"location":"reference/toolr/_context/#toolr._context.Context.which","title":"which","text":"<pre><code>which(\n    name: str,\n    mode: int = F_OK | X_OK,\n    path: str | None = None,\n) -&gt; str | None\n</code></pre> <p>Find the path to an executable in the system PATH.</p> <p>This is a wrapper around shutil.which.</p> <p>See shutil.which for more details.</p> Source code in <code>python/toolr/_context.py</code> <pre><code>def which(self, name: str, mode: int = os.F_OK | os.X_OK, path: str | None = None) -&gt; str | None:\n    \"\"\"\n    Find the path to an executable in the system PATH.\n\n    This is a wrapper around [shutil.which][shutil.which].\n\n    See [shutil.which][shutil.which] for more details.\n    \"\"\"\n    return shutil.which(name, mode=mode, path=path)\n</code></pre>"},{"location":"reference/toolr/_exc/","title":"toolr._exc","text":""},{"location":"reference/toolr/_exc/#toolr._exc.ToolrError","title":"ToolrError","text":"<p>               Bases: <code>Exception</code></p> <p>Base exception for all Toolr errors.</p>"},{"location":"reference/toolr/_exc/#toolr._exc.SignatureParameterError","title":"SignatureParameterError","text":"<pre><code>SignatureParameterError(message: str)\n</code></pre> <p>               Bases: <code>ToolrError</code></p> <p>Exception raised when a function signature parameter is invalid.</p> Source code in <code>python/toolr/_exc.py</code> <pre><code>def __init__(self, message: str) -&gt; None:\n    self.message = message\n    super().__init__(message)\n</code></pre>"},{"location":"reference/toolr/_exc/#toolr._exc.SignatureError","title":"SignatureError","text":"<pre><code>SignatureError(message: str, func: Callable | None = None)\n</code></pre> <p>               Bases: <code>SignatureParameterError</code></p> <p>Exception raised when a function signature is invalid.</p> Source code in <code>python/toolr/_exc.py</code> <pre><code>def __init__(self, message: str, func: Callable | None = None) -&gt; None:\n    if func is not None:\n        message = f\"{func.__module__}.{func.__name__}: {message}\"\n    super().__init__(message)\n</code></pre>"},{"location":"reference/toolr/_parser/","title":"toolr._parser","text":""},{"location":"reference/toolr/_parser/#toolr._parser.Parser","title":"Parser","text":"<p>               Bases: <code>Struct</code></p> <p>Singleton parser class that wraps argparse.</p>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.parse_args","title":"parse_args","text":"<pre><code>parse_args(argv: list[str] | None = None) -&gt; Namespace\n</code></pre> <p>Parse CLI.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def parse_args(self, argv: list[str] | None = None) -&gt; Namespace:\n    \"\"\"\n    Parse CLI.\n    \"\"\"\n    if TYPE_CHECKING:\n        assert self.context is not None\n        assert self.parser is not None\n\n    # Log the argv getting executed\n    self.context.debug(f\"Tools executing 'sys.argv': {sys.argv}\")\n    # Process registered imports to allow other modules to register commands\n    # self._process_registered_tool_modules()\n    options = self.parser.parse_args(argv)\n    verbosity = ConsoleVerbosity.NORMAL\n    if options.quiet:\n        verbosity = ConsoleVerbosity.QUIET\n    elif options.debug:\n        verbosity = ConsoleVerbosity.VERBOSE\n    setup_logging(verbosity=verbosity, timestamps=options.timestamps)\n\n    # Late import to avoid circular import issues\n    from toolr.utils._console import Consoles  # noqa: PLC0415\n\n    # Reset verbosity and consoles after parsing the CLI\n    consoles = Consoles.setup(verbosity)\n    structs.force_setattr(self.context, \"verbosity\", verbosity)\n    structs.force_setattr(self.context, \"_console_stderr\", consoles.stderr)\n    structs.force_setattr(self.context, \"_console_stdout\", consoles.stdout)\n    if \"func\" not in options:\n        self.context.exit(1, \"No command was passed.\")\n    structs.force_setattr(self, \"options\", options)\n    log.debug(\"CLI parsed options %s\", options)\n    return options\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.run","title":"run","text":"<pre><code>run() -&gt; None\n</code></pre> <p>Run the command.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def run(self) -&gt; None:\n    \"\"\"\n    Run the command.\n    \"\"\"\n    if self.options is None:\n        err_msg = \"parser.parse_args() was not called.\"\n        raise RuntimeError(err_msg)\n    self.options.func(self.context, self.options)\n    self.exit(0)\n</code></pre>"},{"location":"reference/toolr/_parser/#toolr._parser.Parser.__getattr__","title":"__getattr__","text":"<pre><code>__getattr__(attr: str) -&gt; Any\n</code></pre> <p>Proxy unknown attributes to the parser instance.</p> Source code in <code>python/toolr/_parser.py</code> <pre><code>def __getattr__(self, attr: str) -&gt; Any:\n    \"\"\"\n    Proxy unknown attributes to the parser instance.\n    \"\"\"\n    if attr == \"options\":\n        return self.__getattribute__(attr)\n    return getattr(self.parser, attr)\n</code></pre>"},{"location":"reference/toolr/_registry/","title":"toolr._registry","text":""},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup","title":"CommandGroup","text":"<p>               Bases: <code>Struct</code></p> <p>A group of commands under a common namespace.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.full_name","title":"full_name  <code>property</code>","text":"<pre><code>full_name: str\n</code></pre> <p>Get the full dot-notation name of this command group.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command","title":"command","text":"<pre><code>command(name: F) -&gt; F\n</code></pre><pre><code>command(name: str) -&gt; Callable[[F], F]\n</code></pre> <pre><code>command(name: str | F) -&gt; Callable[[F], F] | F\n</code></pre> <p>Register a new command.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str | F</code> <p>Name of the command. If not passed, the function name will be used.</p> required <p>Returns:</p> Type Description <code>Callable[[F], F] | F</code> <p>A decorator function that registers the command</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command(self, name: str | F) -&gt; Callable[[F], F] | F:\n    \"\"\"Register a new command.\n\n    Args:\n        name: Name of the command. If not passed, the function name will be used.\n\n    Returns:\n        A decorator function that registers the command\n    \"\"\"\n    if isinstance(name, FunctionType):\n        # If we were not passed a name in the decorator call, we're being called with a function\n        # and we need to use the function name as the command name\n        return self.command(name.__name__.replace(\"_\", \"-\"))(name)\n\n    if TYPE_CHECKING:\n        assert isinstance(name, str)\n\n    def decorator(func: F) -&gt; F:\n        if name in self.__commands:\n            log.debug(\"Command '%s' already exists in group '%s', overriding\", name, self.full_name)\n        self.__commands[name] = func\n        return func\n\n    return decorator\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.command_group","title":"command_group","text":"<pre><code>command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n) -&gt; CommandGroup\n</code></pre> <p>Create a nested command group within this group.</p> <p>This is a wrapper around the command_group function that sets the parent to this group's full name.</p> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    self,\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Create a nested command group within this group.\n\n    This is a wrapper around the [command_group][toolr._registry.command_group] function\n    that sets the parent to this group's full name.\n\n    Returns:\n        A CommandGroup instance\n    \"\"\"\n    return command_group(\n        name,\n        title,\n        description=description,\n        parent=self.full_name,\n        long_description=long_description,\n        docstring=docstring,\n    )\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandGroup.get_commands","title":"get_commands","text":"<pre><code>get_commands() -&gt; dict[str, Callable[..., Any]]\n</code></pre> <p>Get the commands in this group.</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def get_commands(self) -&gt; dict[str, Callable[..., Any]]:\n    \"\"\"Get the commands in this group.\"\"\"\n    return {name: self.__commands[name] for name in sorted(self.__commands)}\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry","title":"CommandRegistry","text":"<p>               Bases: <code>Struct</code></p> <p>Registry for CLI commands and their subcommands.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.parser","title":"parser  <code>property</code>","text":"<pre><code>parser: Parser\n</code></pre> <p>Get the parser for this registry.</p>"},{"location":"reference/toolr/_registry/#toolr._registry.CommandRegistry.discover_and_build","title":"discover_and_build","text":"<pre><code>discover_and_build(parser: Parser | None = None) -&gt; None\n</code></pre> <p>Discover all commands and build the parser hierarchy.</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def discover_and_build(self, parser: Parser | None = None) -&gt; None:\n    \"\"\"Discover all commands and build the parser hierarchy.\"\"\"\n    if parser is not None:\n        self._set_parser(parser)\n    self._discover_commands()\n    self._build_parsers()\n</code></pre>"},{"location":"reference/toolr/_registry/#toolr._registry.command_group","title":"command_group","text":"<pre><code>command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n    parent: str | None = None,\n) -&gt; CommandGroup\n</code></pre> <p>Register a new command group.</p> <p>If you pass <code>docstring</code>, you won't be allowed to pass <code>description</code> or <code>long_description</code>. Those will be parsed by docstring-parser. The first line of the docstring will be used as the description, the rest will be used as the long description.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>Name of the command group</p> required <code>title</code> <code>str</code> <p>Title for the command group</p> required <code>description</code> <code>str | None</code> <p>Description for the command group</p> <code>None</code> <code>long_description</code> <code>str | None</code> <p>Long description for the command group</p> <code>None</code> <code>docstring</code> <code>str | None</code> <p>Docstring for the command group</p> <code>None</code> <code>parent</code> <code>str | None</code> <p>Optional parent command path using dot notation (e.g. \"tools.docker.build\")</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandGroup</code> <p>A CommandGroup instance</p> Source code in <code>python/toolr/_registry.py</code> <pre><code>def command_group(\n    name: str,\n    title: str,\n    description: str | None = None,\n    long_description: str | None = None,\n    docstring: str | None = None,\n    parent: str | None = None,\n) -&gt; CommandGroup:\n    \"\"\"Register a new command group.\n\n    If you pass ``docstring``, you won't be allowed to pass ``description`` or ``long_description``.\n    Those will be parsed by [docstring-parser](https://pypi.org/project/docstring-parser/).\n    The first line of the docstring will be used as the description, the rest will be used as the long description.\n\n    Args:\n        name: Name of the command group\n        title: Title for the command group\n        description: Description for the command group\n        long_description: Long description for the command group\n        docstring: Docstring for the command group\n        parent: Optional parent command path using dot notation (e.g. \"tools.docker.build\")\n\n    Returns:\n        A CommandGroup instance\n\n    \"\"\"\n    if parent is not None and not parent.startswith(\"tools.\"):\n        parent = f\"tools.{parent}\"\n    elif parent is None:\n        parent = \"tools\"\n\n    collector = _get_command_group_storage()\n\n    group: CommandGroup | None = collector.get(f\"{parent}.{name}\")\n    if group is not None:\n        # In this case, we return the existing group\n        log.debug(\"Command group '%s' already exists, returning existing group\", f\"{parent}.{name}\")\n        return group\n\n    if docstring is not None:\n        if description is not None or long_description is not None:\n            err_msg = \"You can't pass both docstring and description or long_description\"\n            raise ValueError(err_msg)\n        parsed_docstring = Docstring.parse(docstring)\n        description = parsed_docstring.short_description\n        long_description = parsed_docstring.long_description\n    elif description is None:\n        err_msg = \"You must at least pass either the 'docstring' or 'description' argument\"\n        raise ValueError(err_msg)\n\n    if TYPE_CHECKING:\n        assert description is not None\n\n    # Create the command group\n    collector[f\"{parent}.{name}\"] = group = CommandGroup(\n        name=name,\n        title=title,\n        description=description,\n        parent=parent,\n        long_description=long_description,\n    )\n    return group\n</code></pre>"},{"location":"reference/toolr/testing/","title":"toolr.testing","text":"<p>Utilities for testing ToolR and supported commands.</p>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester","title":"CommandsTester","text":"<p>Helper class to simplify testing command discovery.</p>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.collected_command_groups","title":"collected_command_groups","text":"<pre><code>collected_command_groups() -&gt; dict[str, CommandGroup]\n</code></pre> <p>Get the collected command groups.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def collected_command_groups(self) -&gt; dict[str, CommandGroup]:\n    \"\"\"\n    Get the collected command groups.\n    \"\"\"\n    return {**self.command_group_collector}\n</code></pre>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.__enter__","title":"__enter__","text":"<pre><code>__enter__() -&gt; Self\n</code></pre> <p>Enter the context manager.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def __enter__(self) -&gt; Self:\n    \"\"\"\n    Enter the context manager.\n    \"\"\"\n    sys.modules.clear()\n    sys.modules.update(self.sys_modules)\n    os.chdir(self.search_path)\n    if self.skip_loading_entry_points:\n        self.entry_points_patcher.start()\n    self.command_group_patcher.start()\n    sys.path.insert(0, str(self.search_path))\n    return self\n</code></pre>"},{"location":"reference/toolr/testing/#toolr.testing.CommandsTester.__exit__","title":"__exit__","text":"<pre><code>__exit__(*args: object) -&gt; None\n</code></pre> <p>Exit the context manager.</p> Source code in <code>python/toolr/testing.py</code> <pre><code>def __exit__(self, *args: object) -&gt; None:\n    \"\"\"\n    Exit the context manager.\n    \"\"\"\n    os.chdir(self.cwd)\n    self.command_group_patcher.stop()\n    if self.skip_loading_entry_points:\n        self.entry_points_patcher.stop()\n    self.command_group_collector.clear()\n    sys.path[:] = self.sys_path\n</code></pre>"},{"location":"reference/toolr/utils/_console/","title":"toolr.utils._console","text":""},{"location":"reference/toolr/utils/_console/#toolr.utils._console.ConsoleVerbosity","title":"ConsoleVerbosity","text":"<p>               Bases: <code>IntEnum</code></p> <p>Console verbosity levels.</p>"},{"location":"reference/toolr/utils/_console/#toolr.utils._console.ConsoleVerbosity.__repr__","title":"__repr__","text":"<pre><code>__repr__() -&gt; str\n</code></pre> <p>Return a string representation of the console verbosity.</p> Source code in <code>python/toolr/utils/_console.py</code> <pre><code>def __repr__(self) -&gt; str:\n    \"\"\"\n    Return a string representation of the console verbosity.\n    \"\"\"\n    return self.name.lower()\n</code></pre>"},{"location":"reference/toolr/utils/_docstrings/","title":"toolr.utils._docstrings","text":""},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.DocstringExample","title":"DocstringExample","text":"<p>               Bases: <code>Struct</code></p> <p>Example of a docstring.</p>"},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.DocstringVersionChanged","title":"DocstringVersionChanged","text":"<p>               Bases: <code>Struct</code></p> <p>Version changed entry with version as key and description as value.</p>"},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.Docstring","title":"Docstring","text":"<p>               Bases: <code>Struct</code></p> <p>Optimized docstring representation using direct msgspec fields.</p>"},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.Docstring.full_description","title":"full_description  <code>property</code>","text":"<pre><code>full_description: str\n</code></pre> <p>Generate a full description combining all docstring sections using markdown.</p>"},{"location":"reference/toolr/utils/_docstrings/#toolr.utils._docstrings.Docstring.parse","title":"parse  <code>classmethod</code>","text":"<pre><code>parse(docstring: str) -&gt; Docstring\n</code></pre> <p>Parse a docstring using our rust implementation.</p> Source code in <code>python/toolr/utils/_docstrings.py</code> <pre><code>@classmethod\ndef parse(cls, docstring: str) -&gt; Docstring:\n    \"\"\"Parse a docstring using our rust implementation.\"\"\"\n    parser = DocstringParser()\n    raw_data = parser.parse(docstring)\n    return msgspec.convert(raw_data, cls)\n</code></pre>"},{"location":"reference/toolr/utils/_imports/","title":"toolr.utils._imports","text":"<p>Imports related utilities.</p>"},{"location":"reference/toolr/utils/_imports/#toolr.utils._imports.report_on_import_errors","title":"report_on_import_errors","text":"<pre><code>report_on_import_errors(message: str) -&gt; Iterator[None]\n</code></pre> <p>Catch import errors and raise a CommandDependencyNotFoundError.</p> Source code in <code>python/toolr/utils/_imports.py</code> <pre><code>@contextmanager\ndef report_on_import_errors(message: str) -&gt; Iterator[None]:\n    \"\"\"\n    Catch import errors and raise a CommandDependencyNotFoundError.\n    \"\"\"\n    try:\n        yield\n    except ModuleNotFoundError as exc:\n        # Suppress the current frame (the yield line) from the traceback\n        # We just want to show the user the import error from the code that actually uses the command\n        if TYPE_CHECKING:\n            assert exc.__traceback__ is not None\n        exc.__traceback__ = exc.__traceback__.tb_next\n        log.warning(message, exc_info=exc)\n</code></pre>"},{"location":"reference/toolr/utils/_logs/","title":"toolr.utils._logs","text":""},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.ExtraFormatter","title":"ExtraFormatter","text":"<p>               Bases: <code>Formatter</code></p> <p>Custom formatter that appends a JSON with the extra parameters to the output of the default formatter.</p> <p>Inspired on JsonFormatter.merge_record_extra https://github.com/nhairs/python-json-logger/blob/v3.3.0/src/pythonjsonlogger/core.py#L100-L124</p>"},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.DuplicateTimesFormatter","title":"DuplicateTimesFormatter","text":"<pre><code>DuplicateTimesFormatter(*args: Any, **kwargs: Any)\n</code></pre> <p>               Bases: <code>ExtraFormatter</code></p> <p>Formatter that adds a timestamp to the message, if it's not a duplicate.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def __init__(self, *args: Any, **kwargs: Any) -&gt; None:\n    super().__init__(*args, **kwargs)\n    self._last_timestamp: str | None = None\n</code></pre>"},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.include_timestamps","title":"include_timestamps","text":"<pre><code>include_timestamps() -&gt; bool\n</code></pre> <p>Return True if any of the configured logging handlers includes timestamps.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def include_timestamps() -&gt; bool:\n    \"\"\"\n    Return True if any of the configured logging handlers includes timestamps.\n    \"\"\"\n    return any(handler.formatter is TIMESTAMP_FORMATTER for handler in logging.root.handlers)\n</code></pre>"},{"location":"reference/toolr/utils/_logs/#toolr.utils._logs.setup_logging","title":"setup_logging","text":"<pre><code>setup_logging(\n    verbosity: ConsoleVerbosity, timestamps: bool = False\n) -&gt; None\n</code></pre> <p>Setup logging level and logging handler formatter.</p> Source code in <code>python/toolr/utils/_logs.py</code> <pre><code>def setup_logging(verbosity: ConsoleVerbosity, timestamps: bool = False) -&gt; None:\n    \"\"\"\n    Setup logging level and logging handler formatter.\n    \"\"\"\n    match verbosity:\n        case ConsoleVerbosity.VERBOSE:\n            logging.root.setLevel(logging.DEBUG)\n        case ConsoleVerbosity.QUIET:\n            logging.root.setLevel(logging.CRITICAL + 1)\n        case _:\n            logging.root.setLevel(logging.INFO)\n\n    formatter: logging.Formatter\n    if timestamps:\n        formatter = TIMESTAMP_FORMATTER\n    else:\n        formatter = NO_TIMESTAMP_FORMATTER\n    for handler in logging.root.handlers:\n        handler.setFormatter(formatter)\n</code></pre>"},{"location":"reference/toolr/utils/_signature/","title":"toolr.utils._signature","text":"<p>Utilities to parse function signatures.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.VarArg","title":"VarArg","text":"<p>               Bases: <code>Arg</code>, <code>Struct</code></p> <p>VarArg is a special case of Arg that is used to represent a variable number of arguments.</p>"},{"location":"reference/toolr/utils/_signature/#toolr.utils._signature.arg","title":"arg","text":"<pre><code>arg(\n    *,\n    aliases: list[str] | None = None,\n    required: bool | None = None,\n    metavar: str | None = None,\n    action: str | None = None,\n    choices: list[Any] | None = None,\n    nargs: NargsType | None = None,\n    group: str | None = None,\n) -&gt; ArgumentAnnotation\n</code></pre> <p>Create an ArgumentAnnotation.</p> <p>This function is meant to be used with :class:<code>typing.Annotated</code> to create an ArgumentAnnotation.</p> <p>Parameters:</p> Name Type Description Default <code>aliases</code> <code>list[str] | None</code> <p>Aliases for the argument.</p> <code>None</code> <code>required</code> <code>bool | None</code> <p>Whether the argument is required.</p> <code>None</code> <code>metavar</code> <code>str | None</code> <p>The metavar for the argument.</p> <code>None</code> <code>action</code> <code>str | None</code> <p>The action for the argument.</p> <code>None</code> <code>choices</code> <code>list[Any] | None</code> <p>The choices for the argument.</p> <code>None</code> <code>nargs</code> <code>NargsType | None</code> <p>The number of arguments to accept.</p> <code>None</code> <code>group</code> <code>str | None</code> <p>The name of the mutually exclusive group for the argument.</p> <code>None</code> Source code in <code>python/toolr/utils/_signature.py</code> <pre><code>def arg(\n    *,\n    aliases: list[str] | None = None,\n    required: bool | None = None,\n    metavar: str | None = None,\n    action: str | None = None,\n    choices: list[Any] | None = None,\n    nargs: NargsType | None = None,\n    group: str | None = None,\n) -&gt; ArgumentAnnotation:\n    \"\"\"\n    Create an ArgumentAnnotation.\n\n    This function is meant to be used with :class:`typing.Annotated` to create an ArgumentAnnotation.\n\n    Args:\n        aliases: Aliases for the argument.\n        required: Whether the argument is required.\n        metavar: The metavar for the argument.\n        action: The action for the argument.\n        choices: The choices for the argument.\n        nargs: The number of arguments to accept.\n        group: The name of the mutually exclusive group for the argument.\n    \"\"\"\n    return ArgumentAnnotation(\n        aliases=aliases,\n        required=required,\n        metavar=metavar,\n        action=action,\n        choices=choices,\n        nargs=nargs,\n        group=group,\n    )\n</code></pre>"},{"location":"reference/toolr/utils/command/","title":"toolr.utils.command","text":"<p>Public interface to the rust command extension module.</p> <p>It provides a simple interface to run commands and stream/capture their output.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.CommandResult","title":"CommandResult","text":"<p>               Bases: <code>Struct</code>, <code>Generic[T]</code></p> <p>The result of a command execution.</p>"},{"location":"reference/toolr/utils/command/#toolr.utils.command.run","title":"run","text":"<pre><code>run(\n    args: Sequence[str],\n    *,\n    cwd: str | Path | None = None,\n    env: ENVIRON = None,\n    input: str | bytes | None = None,\n    stream_output: bool = False,\n    capture_output: bool = False,\n    text: bool = True,\n    encoding: str | None = \"utf-8\",\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n) -&gt; CommandResult[str] | CommandResult[bytes]\n</code></pre> <p>Run a command in a subprocess.</p> <p>Parameters:</p> Name Type Description Default <code>args</code> <code>Sequence[str]</code> <p>Command and arguments to run</p> required <code>cwd</code> <code>str | Path | None</code> <p>Current working directory to run the command in. Defaults to the current directory.</p> <code>None</code> <code>env</code> <code>ENVIRON</code> <p>Environment variables to pass to the command</p> <code>None</code> <code>input</code> <code>str | bytes | None</code> <p>Input data to pass to the command</p> <code>None</code> <code>stream_output</code> <code>bool</code> <p>Whether to stream output to stdout/stderr</p> <code>False</code> <code>capture_output</code> <code>bool</code> <p>Whether to capture output to return</p> <code>False</code> <code>text</code> <code>bool</code> <p>Whether to return output as text or bytes</p> <code>True</code> <code>encoding</code> <code>str | None</code> <p>Encoding to use for text output</p> <code>'utf-8'</code> <code>timeout_secs</code> <code>float | None</code> <p>Maximum time to wait for command completion</p> <code>None</code> <code>no_output_timeout_secs</code> <code>float | None</code> <p>Maximum time to wait without output</p> <code>None</code> <p>Returns:</p> Type Description <code>CommandResult[str] | CommandResult[bytes]</code> <p>CommandResult object containing stdout, stderr, and return code</p> <p>Raises:</p> Type Description <code>CommandError</code> <p>If any of the pre-run checks fail or an operational failure happens.</p> <code>CommandTimeoutError</code> <p>If the command times out</p> <code>CommandTimeoutNoOutputError</code> <p>If the command produces no output for too long</p> Source code in <code>python/toolr/utils/command.py</code> <pre><code>def run(  # noqa: PLR0915\n    args: Sequence[str],\n    *,\n    cwd: str | pathlib.Path | None = None,\n    env: ENVIRON = None,\n    input: str | bytes | None = None,  # noqa: A002\n    stream_output: bool = False,\n    capture_output: bool = False,\n    text: bool = True,\n    encoding: str | None = \"utf-8\",\n    timeout_secs: float | None = None,\n    no_output_timeout_secs: float | None = None,\n) -&gt; CommandResult[str] | CommandResult[bytes]:\n    \"\"\"\n    Run a command in a subprocess.\n\n    Args:\n        args: Command and arguments to run\n        cwd: Current working directory to run the command in. Defaults to the current directory.\n        env: Environment variables to pass to the command\n        input: Input data to pass to the command\n        stream_output: Whether to stream output to stdout/stderr\n        capture_output: Whether to capture output to return\n        text: Whether to return output as text or bytes\n        encoding: Encoding to use for text output\n        timeout_secs: Maximum time to wait for command completion\n        no_output_timeout_secs: Maximum time to wait without output\n\n    Returns:\n        CommandResult object containing stdout, stderr, and return code\n\n    Raises:\n        CommandError: If any of the pre-run checks fail or an operational failure happens.\n        CommandTimeoutError: If the command times out\n        CommandTimeoutNoOutputError: If the command produces no output for too long\n    \"\"\"\n    # Stream output is only supported with text=True\n    if stream_output and not text:\n        err_msg = \"stream_output=True requires text=True\"\n        raise ValueError(err_msg)\n\n    if cwd is None:\n        cwd = pathlib.Path.cwd()\n\n    # Initialize file variables with explicit types\n    stdout_file: IO[Any] | None = None\n    stderr_file: IO[Any] | None = None\n    stdout_fd: int | None = None\n    stderr_fd: int | None = None\n    sys_stdout_fd: int | None = None\n    sys_stderr_fd: int | None = None\n\n    try:\n        # Process the input data\n        input_bytes = None\n        if input is not None:\n            if isinstance(input, str):\n                input_bytes = input.encode(encoding or \"utf-8\")\n            else:\n                input_bytes = input\n\n        # Prepare environment\n        env_dict: dict[str, str] = {}\n        if env:\n            env_dict.update(env)\n        else:\n            # If no environment provided, inherit the current environment\n            env_dict.update(os.environ)\n\n        # Set up stdout/stderr handling\n        if capture_output:\n            if text:\n                stdout_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"w+\", encoding=encoding)  # noqa: SIM115\n            else:\n                stdout_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n                stderr_file = tempfile.TemporaryFile(mode=\"wb+\")  # noqa: SIM115\n\n            stdout_fd = stdout_file.fileno()\n            stderr_fd = stderr_file.fileno()\n\n        # Get sys.stdout and sys.stderr file descriptors if streaming\n        if stream_output:\n            try:\n                sys_stdout_fd = sys.stdout.fileno()\n                sys_stderr_fd = sys.stderr.fileno()\n            except io.UnsupportedOperation:\n                if TYPE_CHECKING:\n                    assert sys.__stdout__ is not None\n                    assert sys.__stderr__ is not None\n\n                sys_stdout_fd = sys.__stdout__.fileno()\n                sys_stderr_fd = sys.__stderr__.fileno()\n\n        # Run the command implementation\n        command_args = list(args)\n        returncode = run_command_impl(\n            command_args,\n            cwd=str(cwd),\n            env=env_dict,\n            input=input_bytes,\n            stdout_fd=stdout_fd,\n            stderr_fd=stderr_fd,\n            sys_stdout_fd=sys_stdout_fd,\n            sys_stderr_fd=sys_stderr_fd,\n            timeout_secs=timeout_secs,\n            no_output_timeout_secs=no_output_timeout_secs,\n        )\n\n        if TYPE_CHECKING:\n            assert stdout_file is not None\n            assert stderr_file is not None\n\n        # Rewind files for reading\n        if stdout_file:\n            stdout_file.seek(0)\n        if stderr_file:\n            stderr_file.seek(0)\n\n        # Return the result with correct typing\n        if text is True:\n            return cast(\n                \"CommandResult[str]\",\n                CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n            )\n        return cast(\n            \"CommandResult[bytes]\",\n            CommandResult(args=command_args, stdout=stdout_file, stderr=stderr_file, returncode=returncode),\n        )\n\n    except Exception as exc:\n        # Clean up on error\n        if stdout_file and hasattr(stdout_file, \"close\"):\n            stdout_file.close()\n        if stderr_file and hasattr(stderr_file, \"close\"):\n            stderr_file.close()\n\n        # Re-raise the exception\n        raise exc from None\n</code></pre>"},{"location":"usage/","title":"How to use","text":"<p>It's important to note that ToolR relies on proper typing of the python functions that will become commands. If fact, it will complain and error out if typing information is missing or unable to parse.</p> <p>It's also important to note that the function must also have a properly written docstring using google style docstrings.</p> <pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\ngroup = command_group(\"example\", title=\"Example\", description=\"Example commands\")\n\n\n@group.command\ndef echo(ctx: Context, what: str):\n    \"\"\"\n    Command title line.\n\n    This is the command description, it can span several lines.\n\n    Args:\n        what: What to echo.\n    \"\"\"\n    ctx.print(what)\n</code></pre> <p>Let's see it!</p> <pre><code>toolr example -h\nUsage: toolr example [-h] {echo} ...\n\nExample commands\n\nOptions:\n  -h, --help  show this help message and exit\n\nExample:\n  Example commands\n\n  {echo}\n    echo      Command title line.\n</code></pre> <p>And now the command help:</p> <pre><code>toolr example echo -h\nUsage: toolr example echo [-h] WHAT\n\nThis is the command description, it can span several lines.\n\nPositional Arguments:\n  WHAT        What to echo.\n\nOptions:\n  -h, --help  show this help message and exit\n</code></pre>"},{"location":"usage/#roundup-1","title":"Roundup #1","text":"<p>So far you've seen a few important pieces:</p> <ul> <li><code>command_group</code></li> <li><code>Context</code></li> </ul>"},{"location":"usage/#docstrings","title":"Docstrings","text":"<p>Docstrings are really useful and can greatly improve the CLI UX:</p> <pre><code>\"\"\"\nComplete example.\n\nThe purpose is to provide an extensive usage example, kind if like TDD\n\n| Example | Description |\n|---------|-------------|\n| hello   | Say hello.  |\n| goodbye | Say goodbye.|\n| multiply| Multiply two numbers.|\n\n\n\n\"\"\"\n\nfrom __future__ import annotations\n\nimport shutil\nfrom enum import StrEnum\nfrom typing import Annotated\nfrom typing import NoReturn\n\nfrom toolr import Context\nfrom toolr import arg\nfrom toolr import command_group\n\ngroup = command_group(\"example\", title=\"Example\", docstring=__doc__)\n\n\n@group.command\ndef hello(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Say hello.\n\n    This is the long description about the hello command.\n    \"\"\"\n    ctx.info(\"Hello, world!\")\n\n\n@group.command(\"goodbye\")\ndef say_goodbye(ctx: Context, name: str | None = None) -&gt; NoReturn:\n    \"\"\"\n    Say goodbye.\n\n    Args:\n        name: Name to say goodbye to. If not provided, defaults to \"world\".\n    \"\"\"\n    if name is None:\n        name = \"world\"\n    ctx.info(f\"Goodbye, {name}!\")\n\n\n@group.command\ndef multiply(ctx: Context, a: int, b: int, verbose: bool = False) -&gt; NoReturn:\n    \"\"\"\n    Multiply two numbers.\n\n    Args:\n        a: First number.\n        b: Second number.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    result = a * b\n    if verbose:\n        ctx.info(f\"{a} * {b} = {result}\")\n    else:\n        ctx.info(result)\n\n\nclass Operation(StrEnum):\n    ADD = \"add\"\n    SUBTRACT = \"subtract\"\n    MULTIPLY = \"multiply\"\n    DIVIDE = \"divide\"\n\n\n@group.command\ndef math(\n    ctx: Context,\n    a: int,\n    b: int,\n    operation: Annotated[Operation, arg(aliases=[\"-o\", \"--op\"])] = Operation.ADD,\n    verbose: bool = False,\n) -&gt; NoReturn:\n    \"\"\"\n    Perform a mathematical operation.\n\n    Args:\n        a: First number.\n        b: Second number.\n        operation: Operation to perform.\n        verbose: Whether to print the result calculation. Defaults to False, print only the result.\n    \"\"\"\n    match operation:\n        case Operation.ADD:\n            value = a + b\n            log_msg = f\"{a} + {b} = {value}\"\n        case Operation.SUBTRACT:\n            value = a - b\n            log_msg = f\"{a} - {b} = {value}\"\n        case Operation.MULTIPLY:\n            value = a * b\n            log_msg = f\"{a} * {b} = {value}\"\n        case Operation.DIVIDE:\n            if b == 0:\n                ctx.error(\"Division by zero!\")\n                return\n            value = a / b\n            log_msg = f\"{a} / {b} = {value}\"\n        case _:\n            raise ValueError(f\"Invalid operation: {operation}\")\n    if verbose:\n        ctx.info(log_msg)\n    else:\n        ctx.info(value)\n\n\n@group.command\ndef py_version(ctx: Context) -&gt; NoReturn:\n    \"\"\"\n    Show Python version.\n\n    This command demonstrates how to run subprocess commands and capture their output.\n    \"\"\"\n    python = shutil.which(\"python\")\n    ret = ctx.run(python, \"--version\", capture_output=True, stream_output=False)\n    ctx.info(\"Python version\", ret.stdout.read().strip())\n</code></pre> <p>It can even render some markdown tables!</p>"},{"location":"usage/#module-help","title":"Module Help","text":"<pre><code>toolr example -h\nUsage: toolr example [-h] {hello,goodbye,multiply,math} ...\n\nComplete example.\n\nOptions:\n  -h, --help            show this help message and exit\n\nExample:\n  The purpose is to provide an extensive usage example, kind if like TDD\n\n    Example    Description\n   \u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\n    hello      Say hello.\n    goodbye    Say goodbye.\n    multiply   Multiply two numbers.\n\n  {hello,goodbye,multiply,math}\n    hello               Say hello.\n    goodbye             Say goodbye.\n    multiply            Multiply two numbers.\n    math                Perform a mathematical operation.\n</code></pre>"},{"location":"usage/#math-command-help","title":"<code>math</code> command help","text":"<pre><code>toolr example math -h\nUsage: toolr example math [-h] [--operation OPERATION] [--verbose] A B\n\nPerform a mathematical operation.\n\nPositional Arguments:\n  A                     First number.\n  B                     Second number.\n\nOptions:\n  -h, --help            show this help message and exit\n  --operation, -o, --op OPERATION\n                        Operation to perform. Choices: 'add', 'subtract', 'multiply', 'divide'. (default: add)\n  --verbose             Whether to print the result calculation. Defaults to False, print only the result. (default: False)\n</code></pre>"},{"location":"usage/#advanced-topics","title":"Advanced Topics","text":""},{"location":"usage/#mutually-exclusive-arguments","title":"Mutually Exclusive Arguments","text":"<p>ToolR supports mutually exclusive argument groups, which allow you to define sets of arguments where only one can be used at a time. This is useful for scenarios like verbosity levels, output formats, or alternative processing modes.</p>"},{"location":"usage/#basic-usage","title":"Basic Usage","text":"<p>Use the <code>group</code> parameter in the <code>arg()</code> function to specify which mutually exclusive group an argument belongs to:</p> <pre><code>from __future__ import annotations\n\nfrom typing import Annotated\n\nfrom toolr import Context\nfrom toolr import arg\n\n\ndef process_file(\n    ctx: Context,\n    filename: str,\n    *,\n    verbose: Annotated[bool, arg(group=\"verbosity\")] = False,\n    quiet: Annotated[bool, arg(group=\"verbosity\")] = False,\n) -&gt; None:\n    \"\"\"Process a file with configurable verbosity.\n\n    Args:\n        filename: The file to process.\n        verbose: Enable verbose output.\n        quiet: Suppress all output.\n    \"\"\"\n    if verbose:\n        ctx.info(f\"Processing {filename} with verbose output...\")\n    elif quiet:\n        # Process silently\n        pass\n    else:\n        ctx.info(f\"Processing {filename}...\")\n</code></pre>"},{"location":"usage/#verbosedebug-example","title":"Verbose/Debug Example","text":"<p>Here's a more comprehensive example showing different verbosity and debug levels:</p> <pre><code>from __future__ import annotations\n\nfrom typing import Annotated\n\nfrom toolr import Context\nfrom toolr import arg\n\n\ndef analyze_data(\n    ctx: Context,\n    input_file: str,\n    *,\n    # Verbosity group - only one can be used\n    verbose: Annotated[bool, arg(group=\"verbosity\")] = False,\n    quiet: Annotated[bool, arg(group=\"verbosity\")] = False,\n    debug: Annotated[bool, arg(group=\"verbosity\")] = False,\n    # Output format group - only one can be used\n    json: Annotated[bool, arg(group=\"format\")] = False,\n    yaml: Annotated[bool, arg(group=\"format\")] = False,\n    csv: Annotated[bool, arg(group=\"format\")] = False,\n) -&gt; None:\n    \"\"\"Analyze data with multiple configuration options.\n\n    Args:\n        input_file: Input file to analyze.\n        verbose: Enable verbose output.\n        quiet: Suppress all output.\n        debug: Enable debug output with detailed logging.\n        json: Output results in JSON format.\n        yaml: Output results in YAML format.\n        csv: Output results in CSV format.\n    \"\"\"\n    # Determine verbosity level\n    if verbose:\n        ctx.info(\"Verbose mode enabled\")\n    elif quiet:\n        ctx.info(\"Quiet mode enabled\")\n    elif debug:\n        ctx.info(\"Debug mode enabled with detailed logging\")\n    else:\n        ctx.info(\"Normal mode\")\n\n    # Determine output format\n    if json:\n        ctx.info(\"Output will be in JSON format\")\n    elif yaml:\n        ctx.info(\"Output will be in YAML format\")\n    elif csv:\n        ctx.info(\"Output will be in CSV format\")\n    else:\n        ctx.info(\"Output will be in default format\")\n\n    ctx.info(f\"Analyzing {input_file}...\")\n</code></pre> <pre><code>\n</code></pre>"},{"location":"usage/#command-line-usage","title":"Command Line Usage","text":"<p>When using the above function, you can only specify one argument from each group:</p> <pre><code># Valid usage - one from each group\ntoolr analyze-data input.txt --verbose --json --fast\n\n# Invalid usage - multiple from verbosity group\ntoolr analyze-data input.txt --verbose --quiet  # Error!\n\n# Invalid usage - multiple from format group  \ntoolr analyze-data input.txt --json --yaml      # Error!\n\n# Valid usage - using defaults for some groups\ntoolr analyze-data input.txt --debug --csv\n</code></pre>"},{"location":"usage/#error-example","title":"Error Example","text":"<pre><code># This will raise an error\ndef invalid_function(\n    ctx: Context,\n    name: Annotated[str, arg(group=\"invalid\")],  # Positional argument in group - ERROR!\n) -&gt; None:\n    \"\"\"This function will fail to parse.\n\n    Args:\n        name: The name parameter.\n    \"\"\"\n</code></pre> <p>This would raise: <code>SignatureError: Positional parameter 'name' cannot be in a mutually exclusive group.</code></p>"},{"location":"usage/#third-party-commands","title":"Third-Party Commands","text":"<p>ToolR supports 3rd-party commands from installable Python packages. This allows you to extend ToolR's functionality by installing additional packages that provide their own commands.</p>"},{"location":"usage/#creating-a-3rd-party-package","title":"Creating a 3rd-Party Package","text":"<p>To create a package that contributes commands to ToolR, you need to:</p> <ol> <li>Define your commands using the standard ToolR API</li> <li>Register an entry point in your package's <code>pyproject.toml</code></li> </ol> <p>Here's an example of a 3rd-party package structure:</p> thirdparty/commands.py<pre><code>from __future__ import annotations\n\nfrom toolr import Context\nfrom toolr import command_group\n\nthird_party_group = command_group(\"third-party\", \"Third Party Tools\", \"Tools from third-party packages\")\n\n@third_party_group.command(\"hello\")\ndef hello_command(ctx: Context, name: str = \"World\") -&gt; None:\n    \"\"\"Say hello to someone.\n\n    Args:\n        ctx: The execution context\n        name: Name to greet (default: World)\n    \"\"\"\n    ctx.print(f\"Hello, {name} from 3rd-party package!\")\n\n@third_party_group.command(\"version\")\ndef version_command(ctx: Context) -&gt; None:\n    \"\"\"Show the version of the 3rd-party package.\n\n    Args:\n        ctx: The execution context\n    \"\"\"\n    ctx.print(\"3rd-party package version 1.0.0\")\n</code></pre>"},{"location":"usage/#entry-point-configuration","title":"Entry Point Configuration","text":"<p>In your package's <code>pyproject.toml</code>, define the entry point:</p> <pre><code>[project.entry-points.\"toolr.tools\"]\n&lt;this name is not important&gt; = \"&lt;package&gt;.&lt;module calling toolr.command_group()&gt;\"\n</code></pre> <p>For example:</p> <pre><code>[project.entry-points.\"toolr.tools\"]\ncommands = \"thirdparty.commands\"\n</code></pre>"},{"location":"usage/#installation-and-discovery","title":"Installation and Discovery","text":"<p>Once installed alongside ToolR, the package will automatically contribute its commands. You can see a complete working example in the ToolR repository.</p>"},{"location":"usage/#command-resolution","title":"Command Resolution","text":"<p>When multiple packages provide commands with the same name:</p> <ul> <li>Repository commands (commands defined in your local <code>tools/</code> directory) override 3rd-party commands</li> <li>If the parent command group is shared, 3rd-party commands augment the existing command group</li> </ul> <p>This allows for flexible command composition while maintaining local control over command behavior.</p>"}]}